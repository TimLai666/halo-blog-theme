const yl = "modulepreload", wl = function (t) { return "/themes/theme-fuwari-2/assets/dist/" + t }, Ns = {}, bl = function (e, n, r) { let o = Promise.resolve(); if (n && n.length > 0) { let l = function (u) { return Promise.all(u.map(d => Promise.resolve(d).then(f => ({ status: "fulfilled", value: f }), f => ({ status: "rejected", reason: f })))) }; const i = document.getElementsByTagName("link"), a = document.querySelector("meta[property=csp-nonce]"), c = a?.nonce || a?.getAttribute("nonce"); o = l(n.map(u => { if (u = wl(u, r), u in Ns) return; Ns[u] = !0; const d = u.endsWith(".css"), f = d ? '[rel="stylesheet"]' : ""; if (!!r) for (let _ = i.length - 1; _ >= 0; _--) { const p = i[_]; if (p.href === u && (!d || p.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${u}"]${f}`)) return; const h = document.createElement("link"); if (h.rel = d ? "stylesheet" : yl, d || (h.as = "script"), h.crossOrigin = "", h.href = u, c && h.setAttribute("nonce", c), document.head.appendChild(h), d) return new Promise((_, p) => { h.addEventListener("load", _), h.addEventListener("error", () => p(new Error(`Unable to preload CSS for ${u}`))) }) })) } function s(i) { const a = new Event("vite:preloadError", { cancelable: !0 }); if (a.payload = i, window.dispatchEvent(a), !a.defaultPrevented) throw i } return o.then(i => { for (const a of i || []) a.status === "rejected" && s(a.reason); return e().catch(s) }) }; var ro = !1, oo = !1, ue = [], so = -1; function xl(t) { Sl(t) } function Sl(t) { ue.includes(t) || ue.push(t), $l() } function El(t) { let e = ue.indexOf(t); e !== -1 && e > so && ue.splice(e, 1) } function $l() { !oo && !ro && (ro = !0, queueMicrotask(Cl)) } function Cl() { ro = !1, oo = !0; for (let t = 0; t < ue.length; t++)ue[t](), so = t; ue.length = 0, so = -1, oo = !1 } var Pe, _e, Oe, Ui, io = !0; function Al(t) { io = !1, t(), io = !0 } function Tl(t) { Pe = t.reactive, Oe = t.release, _e = e => t.effect(e, { scheduler: n => { io ? xl(n) : n() } }), Ui = t.raw } function Hs(t) { _e = t } function kl(t) { let e = () => { }; return [r => { let o = _e(r); return t._x_effects || (t._x_effects = new Set, t._x_runEffects = () => { t._x_effects.forEach(s => s()) }), t._x_effects.add(o), e = () => { o !== void 0 && (t._x_effects.delete(o), Oe(o)) }, o }, () => { e() }] } function Wi(t, e) { let n = !0, r, o = _e(() => { let s = t(); JSON.stringify(s), n ? r = s : queueMicrotask(() => { e(s, r), r = s }), n = !1 }); return () => Oe(o) } var Ki = [], Gi = [], Zi = []; function Pl(t) { Zi.push(t) } function Fo(t, e) { typeof e == "function" ? (t._x_cleanups || (t._x_cleanups = []), t._x_cleanups.push(e)) : (e = t, Gi.push(e)) } function Xi(t) { Ki.push(t) } function Yi(t, e, n) { t._x_attributeCleanups || (t._x_attributeCleanups = {}), t._x_attributeCleanups[e] || (t._x_attributeCleanups[e] = []), t._x_attributeCleanups[e].push(n) } function Ji(t, e) { t._x_attributeCleanups && Object.entries(t._x_attributeCleanups).forEach(([n, r]) => { (e === void 0 || e.includes(n)) && (r.forEach(o => o()), delete t._x_attributeCleanups[n]) }) } function Ol(t) { for (t._x_effects?.forEach(El); t._x_cleanups?.length;)t._x_cleanups.pop()() } var zo = new MutationObserver(Ko), Vo = !1; function Uo() { zo.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), Vo = !0 } function Qi() { Il(), zo.disconnect(), Vo = !1 } var ze = []; function Il() { let t = zo.takeRecords(); ze.push(() => t.length > 0 && Ko(t)); let e = ze.length; queueMicrotask(() => { if (ze.length === e) for (; ze.length > 0;)ze.shift()() }) } function at(t) { if (!Vo) return t(); Qi(); let e = t(); return Uo(), e } var Wo = !1, Yn = []; function Ll() { Wo = !0 } function Ml() { Wo = !1, Ko(Yn), Yn = [] } function Ko(t) { if (Wo) { Yn = Yn.concat(t); return } let e = [], n = new Set, r = new Map, o = new Map; for (let s = 0; s < t.length; s++)if (!t[s].target._x_ignoreMutationObserver && (t[s].type === "childList" && (t[s].removedNodes.forEach(i => { i.nodeType === 1 && i._x_marker && n.add(i) }), t[s].addedNodes.forEach(i => { if (i.nodeType === 1) { if (n.has(i)) { n.delete(i); return } i._x_marker || e.push(i) } })), t[s].type === "attributes")) { let i = t[s].target, a = t[s].attributeName, c = t[s].oldValue, l = () => { r.has(i) || r.set(i, []), r.get(i).push({ name: a, value: i.getAttribute(a) }) }, u = () => { o.has(i) || o.set(i, []), o.get(i).push(a) }; i.hasAttribute(a) && c === null ? l() : i.hasAttribute(a) ? (u(), l()) : u() } o.forEach((s, i) => { Ji(i, s) }), r.forEach((s, i) => { Ki.forEach(a => a(i, s)) }); for (let s of n) e.some(i => i.contains(s)) || Gi.forEach(i => i(s)); for (let s of e) s.isConnected && Zi.forEach(i => i(s)); e = null, n = null, r = null, o = null } function ta(t) { return un($e(t)) } function ln(t, e, n) { return t._x_dataStack = [e, ...$e(n || t)], () => { t._x_dataStack = t._x_dataStack.filter(r => r !== e) } } function $e(t) { return t._x_dataStack ? t._x_dataStack : typeof ShadowRoot == "function" && t instanceof ShadowRoot ? $e(t.host) : t.parentNode ? $e(t.parentNode) : [] } function un(t) { return new Proxy({ objects: t }, Rl) } var Rl = { ownKeys({ objects: t }) { return Array.from(new Set(t.flatMap(e => Object.keys(e)))) }, has({ objects: t }, e) { return e == Symbol.unscopables ? !1 : t.some(n => Object.prototype.hasOwnProperty.call(n, e) || Reflect.has(n, e)) }, get({ objects: t }, e, n) { return e == "toJSON" ? Nl : Reflect.get(t.find(r => Reflect.has(r, e)) || {}, e, n) }, set({ objects: t }, e, n, r) { const o = t.find(i => Object.prototype.hasOwnProperty.call(i, e)) || t[t.length - 1], s = Object.getOwnPropertyDescriptor(o, e); return s?.set && s?.get ? s.set.call(r, n) || !0 : Reflect.set(o, e, n) } }; function Nl() { return Reflect.ownKeys(this).reduce((e, n) => (e[n] = Reflect.get(this, n), e), {}) } function ea(t) { let e = r => typeof r == "object" && !Array.isArray(r) && r !== null, n = (r, o = "") => { Object.entries(Object.getOwnPropertyDescriptors(r)).forEach(([s, { value: i, enumerable: a }]) => { if (a === !1 || i === void 0 || typeof i == "object" && i !== null && i.__v_skip) return; let c = o === "" ? s : `${o}.${s}`; typeof i == "object" && i !== null && i._x_interceptor ? r[s] = i.initialize(t, c, s) : e(i) && i !== r && !(i instanceof Element) && n(i, c) }) }; return n(t) } function na(t, e = () => { }) { let n = { initialValue: void 0, _x_interceptor: !0, initialize(r, o, s) { return t(this.initialValue, () => Hl(r, o), i => ao(r, o, i), o, s) } }; return e(n), r => { if (typeof r == "object" && r !== null && r._x_interceptor) { let o = n.initialize.bind(n); n.initialize = (s, i, a) => { let c = r.initialize(s, i, a); return n.initialValue = c, o(s, i, a) } } else n.initialValue = r; return n } } function Hl(t, e) { return e.split(".").reduce((n, r) => n[r], t) } function ao(t, e, n) { if (typeof e == "string" && (e = e.split(".")), e.length === 1) t[e[0]] = n; else { if (e.length === 0) throw error; return t[e[0]] || (t[e[0]] = {}), ao(t[e[0]], e.slice(1), n) } } var ra = {}; function Rt(t, e) { ra[t] = e } function co(t, e) { let n = Dl(e); return Object.entries(ra).forEach(([r, o]) => { Object.defineProperty(t, `$${r}`, { get() { return o(e, n) }, enumerable: !1 }) }), t } function Dl(t) { let [e, n] = la(t), r = { interceptor: na, ...e }; return Fo(t, n), r } function Bl(t, e, n, ...r) { try { return n(...r) } catch (o) { en(o, t, e) } } function en(t, e, n = void 0) {
    t = Object.assign(t ?? { message: "No error message given." }, { el: e, expression: n }), console.warn(`Alpine Expression Error: ${t.message}

${n ? 'Expression: "' + n + `"

`: ""}`, e), setTimeout(() => { throw t }, 0)
} var qn = !0; function oa(t) { let e = qn; qn = !1; let n = t(); return qn = e, n } function de(t, e, n = {}) { let r; return bt(t, e)(o => r = o, n), r } function bt(...t) { return sa(...t) } var sa = ia; function jl(t) { sa = t } function ia(t, e) { let n = {}; co(n, t); let r = [n, ...$e(t)], o = typeof e == "function" ? ql(r, e) : zl(r, e, t); return Bl.bind(null, t, e, o) } function ql(t, e) { return (n = () => { }, { scope: r = {}, params: o = [] } = {}) => { let s = e.apply(un([r, ...t]), o); Jn(n, s) } } var zr = {}; function Fl(t, e) { if (zr[t]) return zr[t]; let n = Object.getPrototypeOf(async function () { }).constructor, r = /^[\n\s]*if.*\(.*\)/.test(t.trim()) || /^(let|const)\s/.test(t.trim()) ? `(async()=>{ ${t} })()` : t, s = (() => { try { let i = new n(["__self", "scope"], `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`); return Object.defineProperty(i, "name", { value: `[Alpine] ${t}` }), i } catch (i) { return en(i, e, t), Promise.resolve() } })(); return zr[t] = s, s } function zl(t, e, n) { let r = Fl(e, n); return (o = () => { }, { scope: s = {}, params: i = [] } = {}) => { r.result = void 0, r.finished = !1; let a = un([s, ...t]); if (typeof r == "function") { let c = r(r, a).catch(l => en(l, n, e)); r.finished ? (Jn(o, r.result, a, i, n), r.result = void 0) : c.then(l => { Jn(o, l, a, i, n) }).catch(l => en(l, n, e)).finally(() => r.result = void 0) } } } function Jn(t, e, n, r, o) { if (qn && typeof e == "function") { let s = e.apply(n, r); s instanceof Promise ? s.then(i => Jn(t, i, n, r)).catch(i => en(i, o, e)) : t(s) } else typeof e == "object" && e instanceof Promise ? e.then(s => t(s)) : t(e) } var Go = "x-"; function Ie(t = "") { return Go + t } function Vl(t) { Go = t } var Qn = {}; function pt(t, e) { return Qn[t] = e, { before(n) { if (!Qn[n]) { console.warn(String.raw`Cannot find directive \`${n}\`. \`${t}\` will use the default order of execution`); return } const r = le.indexOf(n); le.splice(r >= 0 ? r : le.indexOf("DEFAULT"), 0, t) } } } function Ul(t) { return Object.keys(Qn).includes(t) } function Zo(t, e, n) { if (e = Array.from(e), t._x_virtualDirectives) { let s = Object.entries(t._x_virtualDirectives).map(([a, c]) => ({ name: a, value: c })), i = aa(s); s = s.map(a => i.find(c => c.name === a.name) ? { name: `x-bind:${a.name}`, value: `"${a.value}"` } : a), e = e.concat(s) } let r = {}; return e.map(ha((s, i) => r[s] = i)).filter(pa).map(Gl(r, n)).sort(Zl).map(s => Kl(t, s)) } function aa(t) { return Array.from(t).map(ha()).filter(e => !pa(e)) } var lo = !1, We = new Map, ca = Symbol(); function Wl(t) { lo = !0; let e = Symbol(); ca = e, We.set(e, []); let n = () => { for (; We.get(e).length;)We.get(e).shift()(); We.delete(e) }, r = () => { lo = !1, n() }; t(n), r() } function la(t) { let e = [], n = a => e.push(a), [r, o] = kl(t); return e.push(o), [{ Alpine: dn, effect: r, cleanup: n, evaluateLater: bt.bind(bt, t), evaluate: de.bind(de, t) }, () => e.forEach(a => a())] } function Kl(t, e) { let n = () => { }, r = Qn[e.type] || n, [o, s] = la(t); Yi(t, e.original, s); let i = () => { t._x_ignore || t._x_ignoreSelf || (r.inline && r.inline(t, e, o), r = r.bind(r, t, e, o), lo ? We.get(ca).push(r) : r()) }; return i.runCleanups = s, i } var ua = (t, e) => ({ name: n, value: r }) => (n.startsWith(t) && (n = n.replace(t, e)), { name: n, value: r }), da = t => t; function ha(t = () => { }) { return ({ name: e, value: n }) => { let { name: r, value: o } = fa.reduce((s, i) => i(s), { name: e, value: n }); return r !== e && t(r, e), { name: r, value: o } } } var fa = []; function Xo(t) { fa.push(t) } function pa({ name: t }) { return ma().test(t) } var ma = () => new RegExp(`^${Go}([^:^.]+)\\b`); function Gl(t, e) { return ({ name: n, value: r }) => { let o = n.match(ma()), s = n.match(/:([a-zA-Z0-9\-_:]+)/), i = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], a = e || t[n] || n; return { type: o ? o[1] : null, value: s ? s[1] : null, modifiers: i.map(c => c.replace(".", "")), expression: r, original: a } } } var uo = "DEFAULT", le = ["ignore", "ref", "data", "id", "anchor", "bind", "init", "for", "model", "modelable", "transition", "show", "if", uo, "teleport"]; function Zl(t, e) { let n = le.indexOf(t.type) === -1 ? uo : t.type, r = le.indexOf(e.type) === -1 ? uo : e.type; return le.indexOf(n) - le.indexOf(r) } function Xe(t, e, n = {}) { t.dispatchEvent(new CustomEvent(e, { detail: n, bubbles: !0, composed: !0, cancelable: !0 })) } function me(t, e) { if (typeof ShadowRoot == "function" && t instanceof ShadowRoot) { Array.from(t.children).forEach(o => me(o, e)); return } let n = !1; if (e(t, () => n = !0), n) return; let r = t.firstElementChild; for (; r;)me(r, e, !1), r = r.nextElementSibling } function kt(t, ...e) { console.warn(`Alpine Warning: ${t}`, ...e) } var Ds = !1; function Xl() { Ds && kt("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), Ds = !0, document.body || kt("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), Xe(document, "alpine:init"), Xe(document, "alpine:initializing"), Uo(), Pl(e => Gt(e, me)), Fo(e => Me(e)), Xi((e, n) => { Zo(e, n).forEach(r => r()) }); let t = e => !gr(e.parentElement, !0); Array.from(document.querySelectorAll(va().join(","))).filter(t).forEach(e => { Gt(e) }), Xe(document, "alpine:initialized"), setTimeout(() => { tu() }) } var Yo = [], ga = []; function _a() { return Yo.map(t => t()) } function va() { return Yo.concat(ga).map(t => t()) } function ya(t) { Yo.push(t) } function wa(t) { ga.push(t) } function gr(t, e = !1) { return Le(t, n => { if ((e ? va() : _a()).some(o => n.matches(o))) return !0 }) } function Le(t, e) { if (t) { if (e(t)) return t; if (t._x_teleportBack && (t = t._x_teleportBack), !!t.parentElement) return Le(t.parentElement, e) } } function Yl(t) { return _a().some(e => t.matches(e)) } var ba = []; function Jl(t) { ba.push(t) } var Ql = 1; function Gt(t, e = me, n = () => { }) { Le(t, r => r._x_ignore) || Wl(() => { e(t, (r, o) => { r._x_marker || (n(r, o), ba.forEach(s => s(r, o)), Zo(r, r.attributes).forEach(s => s()), r._x_ignore || (r._x_marker = Ql++), r._x_ignore && o()) }) }) } function Me(t, e = me) { e(t, n => { Ol(n), Ji(n), delete n._x_marker }) } function tu() { [["ui", "dialog", ["[x-dialog], [x-popover]"]], ["anchor", "anchor", ["[x-anchor]"]], ["sort", "sort", ["[x-sort]"]]].forEach(([e, n, r]) => { Ul(n) || r.some(o => { if (document.querySelector(o)) return kt(`found "${o}", but missing ${e} plugin`), !0 }) }) } var ho = [], Jo = !1; function Qo(t = () => { }) { return queueMicrotask(() => { Jo || setTimeout(() => { fo() }) }), new Promise(e => { ho.push(() => { t(), e() }) }) } function fo() { for (Jo = !1; ho.length;)ho.shift()() } function eu() { Jo = !0 } function ts(t, e) { return Array.isArray(e) ? Bs(t, e.join(" ")) : typeof e == "object" && e !== null ? nu(t, e) : typeof e == "function" ? ts(t, e()) : Bs(t, e) } function Bs(t, e) { let n = s => s.split(" ").filter(Boolean), r = s => s.split(" ").filter(i => !t.classList.contains(i)).filter(Boolean), o = s => (t.classList.add(...s), () => { t.classList.remove(...s) }); return e = e === !0 ? e = "" : e || "", o(r(e)) } function nu(t, e) { let n = a => a.split(" ").filter(Boolean), r = Object.entries(e).flatMap(([a, c]) => c ? n(a) : !1).filter(Boolean), o = Object.entries(e).flatMap(([a, c]) => c ? !1 : n(a)).filter(Boolean), s = [], i = []; return o.forEach(a => { t.classList.contains(a) && (t.classList.remove(a), i.push(a)) }), r.forEach(a => { t.classList.contains(a) || (t.classList.add(a), s.push(a)) }), () => { i.forEach(a => t.classList.add(a)), s.forEach(a => t.classList.remove(a)) } } function _r(t, e) { return typeof e == "object" && e !== null ? ru(t, e) : ou(t, e) } function ru(t, e) { let n = {}; return Object.entries(e).forEach(([r, o]) => { n[r] = t.style[r], r.startsWith("--") || (r = su(r)), t.style.setProperty(r, o) }), setTimeout(() => { t.style.length === 0 && t.removeAttribute("style") }), () => { _r(t, n) } } function ou(t, e) { let n = t.getAttribute("style", e); return t.setAttribute("style", e), () => { t.setAttribute("style", n || "") } } function su(t) { return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function po(t, e = () => { }) { let n = !1; return function () { n ? e.apply(this, arguments) : (n = !0, t.apply(this, arguments)) } } pt("transition", (t, { value: e, modifiers: n, expression: r }, { evaluate: o }) => { typeof r == "function" && (r = o(r)), r !== !1 && (!r || typeof r == "boolean" ? au(t, n, e) : iu(t, r, e)) }); function iu(t, e, n) { xa(t, ts, ""), { enter: o => { t._x_transition.enter.during = o }, "enter-start": o => { t._x_transition.enter.start = o }, "enter-end": o => { t._x_transition.enter.end = o }, leave: o => { t._x_transition.leave.during = o }, "leave-start": o => { t._x_transition.leave.start = o }, "leave-end": o => { t._x_transition.leave.end = o } }[n](e) } function au(t, e, n) { xa(t, _r); let r = !e.includes("in") && !e.includes("out") && !n, o = r || e.includes("in") || ["enter"].includes(n), s = r || e.includes("out") || ["leave"].includes(n); e.includes("in") && !r && (e = e.filter((g, v) => v < e.indexOf("out"))), e.includes("out") && !r && (e = e.filter((g, v) => v > e.indexOf("out"))); let i = !e.includes("opacity") && !e.includes("scale"), a = i || e.includes("opacity"), c = i || e.includes("scale"), l = a ? 0 : 1, u = c ? Ve(e, "scale", 95) / 100 : 1, d = Ve(e, "delay", 0) / 1e3, f = Ve(e, "origin", "center"), m = "opacity, transform", h = Ve(e, "duration", 150) / 1e3, _ = Ve(e, "duration", 75) / 1e3, p = "cubic-bezier(0.4, 0.0, 0.2, 1)"; o && (t._x_transition.enter.during = { transformOrigin: f, transitionDelay: `${d}s`, transitionProperty: m, transitionDuration: `${h}s`, transitionTimingFunction: p }, t._x_transition.enter.start = { opacity: l, transform: `scale(${u})` }, t._x_transition.enter.end = { opacity: 1, transform: "scale(1)" }), s && (t._x_transition.leave.during = { transformOrigin: f, transitionDelay: `${d}s`, transitionProperty: m, transitionDuration: `${_}s`, transitionTimingFunction: p }, t._x_transition.leave.start = { opacity: 1, transform: "scale(1)" }, t._x_transition.leave.end = { opacity: l, transform: `scale(${u})` }) } function xa(t, e, n = {}) { t._x_transition || (t._x_transition = { enter: { during: n, start: n, end: n }, leave: { during: n, start: n, end: n }, in(r = () => { }, o = () => { }) { mo(t, e, { during: this.enter.during, start: this.enter.start, end: this.enter.end }, r, o) }, out(r = () => { }, o = () => { }) { mo(t, e, { during: this.leave.during, start: this.leave.start, end: this.leave.end }, r, o) } }) } window.Element.prototype._x_toggleAndCascadeWithTransitions = function (t, e, n, r) { const o = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout; let s = () => o(n); if (e) { t._x_transition && (t._x_transition.enter || t._x_transition.leave) ? t._x_transition.enter && (Object.entries(t._x_transition.enter.during).length || Object.entries(t._x_transition.enter.start).length || Object.entries(t._x_transition.enter.end).length) ? t._x_transition.in(n) : s() : t._x_transition ? t._x_transition.in(n) : s(); return } t._x_hidePromise = t._x_transition ? new Promise((i, a) => { t._x_transition.out(() => { }, () => i(r)), t._x_transitioning && t._x_transitioning.beforeCancel(() => a({ isFromCancelledTransition: !0 })) }) : Promise.resolve(r), queueMicrotask(() => { let i = Sa(t); i ? (i._x_hideChildren || (i._x_hideChildren = []), i._x_hideChildren.push(t)) : o(() => { let a = c => { let l = Promise.all([c._x_hidePromise, ...(c._x_hideChildren || []).map(a)]).then(([u]) => u?.()); return delete c._x_hidePromise, delete c._x_hideChildren, l }; a(t).catch(c => { if (!c.isFromCancelledTransition) throw c }) }) }) }; function Sa(t) { let e = t.parentNode; if (e) return e._x_hidePromise ? e : Sa(e) } function mo(t, e, { during: n, start: r, end: o } = {}, s = () => { }, i = () => { }) { if (t._x_transitioning && t._x_transitioning.cancel(), Object.keys(n).length === 0 && Object.keys(r).length === 0 && Object.keys(o).length === 0) { s(), i(); return } let a, c, l; cu(t, { start() { a = e(t, r) }, during() { c = e(t, n) }, before: s, end() { a(), l = e(t, o) }, after: i, cleanup() { c(), l() } }) } function cu(t, e) { let n, r, o, s = po(() => { at(() => { n = !0, r || e.before(), o || (e.end(), fo()), e.after(), t.isConnected && e.cleanup(), delete t._x_transitioning }) }); t._x_transitioning = { beforeCancels: [], beforeCancel(i) { this.beforeCancels.push(i) }, cancel: po(function () { for (; this.beforeCancels.length;)this.beforeCancels.shift()(); s() }), finish: s }, at(() => { e.start(), e.during() }), eu(), requestAnimationFrame(() => { if (n) return; let i = Number(getComputedStyle(t).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, a = Number(getComputedStyle(t).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3; i === 0 && (i = Number(getComputedStyle(t).animationDuration.replace("s", "")) * 1e3), at(() => { e.before() }), r = !0, requestAnimationFrame(() => { n || (at(() => { e.end() }), fo(), setTimeout(t._x_transitioning.finish, i + a), o = !0) }) }) } function Ve(t, e, n) { if (t.indexOf(e) === -1) return n; const r = t[t.indexOf(e) + 1]; if (!r || e === "scale" && isNaN(r)) return n; if (e === "duration" || e === "delay") { let o = r.match(/([0-9]+)ms/); if (o) return o[1] } return e === "origin" && ["top", "right", "left", "center", "bottom"].includes(t[t.indexOf(e) + 2]) ? [r, t[t.indexOf(e) + 2]].join(" ") : r } var te = !1; function ne(t, e = () => { }) { return (...n) => te ? e(...n) : t(...n) } function lu(t) { return (...e) => te && t(...e) } var Ea = []; function vr(t) { Ea.push(t) } function uu(t, e) { Ea.forEach(n => n(t, e)), te = !0, $a(() => { Gt(e, (n, r) => { r(n, () => { }) }) }), te = !1 } var go = !1; function du(t, e) { e._x_dataStack || (e._x_dataStack = t._x_dataStack), te = !0, go = !0, $a(() => { hu(e) }), te = !1, go = !1 } function hu(t) { let e = !1; Gt(t, (r, o) => { me(r, (s, i) => { if (e && Yl(s)) return i(); e = !0, o(s, i) }) }) } function $a(t) { let e = _e; Hs((n, r) => { let o = e(n); return Oe(o), () => { } }), t(), Hs(e) } function Ca(t, e, n, r = []) { switch (t._x_bindings || (t._x_bindings = Pe({})), t._x_bindings[e] = n, e = r.includes("camel") ? wu(e) : e, e) { case "value": fu(t, n); break; case "style": mu(t, n); break; case "class": pu(t, n); break; case "selected": case "checked": gu(t, e, n); break; default: Aa(t, e, n); break } } function fu(t, e) { if (Pa(t)) t.attributes.value === void 0 && (t.value = e), window.fromModel && (typeof e == "boolean" ? t.checked = Fn(t.value) === e : t.checked = js(t.value, e)); else if (es(t)) Number.isInteger(e) ? t.value = e : !Array.isArray(e) && typeof e != "boolean" && ![null, void 0].includes(e) ? t.value = String(e) : Array.isArray(e) ? t.checked = e.some(n => js(n, t.value)) : t.checked = !!e; else if (t.tagName === "SELECT") yu(t, e); else { if (t.value === e) return; t.value = e === void 0 ? "" : e } } function pu(t, e) { t._x_undoAddedClasses && t._x_undoAddedClasses(), t._x_undoAddedClasses = ts(t, e) } function mu(t, e) { t._x_undoAddedStyles && t._x_undoAddedStyles(), t._x_undoAddedStyles = _r(t, e) } function gu(t, e, n) { Aa(t, e, n), vu(t, e, n) } function Aa(t, e, n) { [null, void 0, !1].includes(n) && xu(e) ? t.removeAttribute(e) : (Ta(e) && (n = e), _u(t, e, n)) } function _u(t, e, n) { t.getAttribute(e) != n && t.setAttribute(e, n) } function vu(t, e, n) { t[e] !== n && (t[e] = n) } function yu(t, e) { const n = [].concat(e).map(r => r + ""); Array.from(t.options).forEach(r => { r.selected = n.includes(r.value) }) } function wu(t) { return t.toLowerCase().replace(/-(\w)/g, (e, n) => n.toUpperCase()) } function js(t, e) { return t == e } function Fn(t) { return [1, "1", "true", "on", "yes", !0].includes(t) ? !0 : [0, "0", "false", "off", "no", !1].includes(t) ? !1 : t ? !!t : null } var bu = new Set(["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected", "shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootserializable"]); function Ta(t) { return bu.has(t) } function xu(t) { return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(t) } function Su(t, e, n) { return t._x_bindings && t._x_bindings[e] !== void 0 ? t._x_bindings[e] : ka(t, e, n) } function Eu(t, e, n, r = !0) { if (t._x_bindings && t._x_bindings[e] !== void 0) return t._x_bindings[e]; if (t._x_inlineBindings && t._x_inlineBindings[e] !== void 0) { let o = t._x_inlineBindings[e]; return o.extract = r, oa(() => de(t, o.expression)) } return ka(t, e, n) } function ka(t, e, n) { let r = t.getAttribute(e); return r === null ? typeof n == "function" ? n() : n : r === "" ? !0 : Ta(e) ? !![e, "true"].includes(r) : r } function es(t) { return t.type === "checkbox" || t.localName === "ui-checkbox" || t.localName === "ui-switch" } function Pa(t) { return t.type === "radio" || t.localName === "ui-radio" } function Oa(t, e) { var n; return function () { var r = this, o = arguments, s = function () { n = null, t.apply(r, o) }; clearTimeout(n), n = setTimeout(s, e) } } function Ia(t, e) { let n; return function () { let r = this, o = arguments; n || (t.apply(r, o), n = !0, setTimeout(() => n = !1, e)) } } function La({ get: t, set: e }, { get: n, set: r }) { let o = !0, s, i, a = _e(() => { let c = t(), l = n(); if (o) r(Vr(c)), o = !1; else { let u = JSON.stringify(c), d = JSON.stringify(l); u !== s ? r(Vr(c)) : u !== d && e(Vr(l)) } s = JSON.stringify(t()), i = JSON.stringify(n()) }); return () => { Oe(a) } } function Vr(t) { return typeof t == "object" ? JSON.parse(JSON.stringify(t)) : t } function $u(t) { (Array.isArray(t) ? t : [t]).forEach(n => n(dn)) } var ae = {}, qs = !1; function Cu(t, e) { if (qs || (ae = Pe(ae), qs = !0), e === void 0) return ae[t]; ae[t] = e, ea(ae[t]), typeof e == "object" && e !== null && e.hasOwnProperty("init") && typeof e.init == "function" && ae[t].init() } function Au() { return ae } var Ma = {}; function Tu(t, e) { let n = typeof e != "function" ? () => e : e; return t instanceof Element ? Ra(t, n()) : (Ma[t] = n, () => { }) } function ku(t) { return Object.entries(Ma).forEach(([e, n]) => { Object.defineProperty(t, e, { get() { return (...r) => n(...r) } }) }), t } function Ra(t, e, n) { let r = []; for (; r.length;)r.pop()(); let o = Object.entries(e).map(([i, a]) => ({ name: i, value: a })), s = aa(o); return o = o.map(i => s.find(a => a.name === i.name) ? { name: `x-bind:${i.name}`, value: `"${i.value}"` } : i), Zo(t, o, n).map(i => { r.push(i.runCleanups), i() }), () => { for (; r.length;)r.pop()() } } var Na = {}; function Pu(t, e) { Na[t] = e } function Ou(t, e) { return Object.entries(Na).forEach(([n, r]) => { Object.defineProperty(t, n, { get() { return (...o) => r.bind(e)(...o) }, enumerable: !1 }) }), t } var Iu = { get reactive() { return Pe }, get release() { return Oe }, get effect() { return _e }, get raw() { return Ui }, version: "3.14.9", flushAndStopDeferringMutations: Ml, dontAutoEvaluateFunctions: oa, disableEffectScheduling: Al, startObservingMutations: Uo, stopObservingMutations: Qi, setReactivityEngine: Tl, onAttributeRemoved: Yi, onAttributesAdded: Xi, closestDataStack: $e, skipDuringClone: ne, onlyDuringClone: lu, addRootSelector: ya, addInitSelector: wa, interceptClone: vr, addScopeToNode: ln, deferMutations: Ll, mapAttributes: Xo, evaluateLater: bt, interceptInit: Jl, setEvaluator: jl, mergeProxies: un, extractProp: Eu, findClosest: Le, onElRemoved: Fo, closestRoot: gr, destroyTree: Me, interceptor: na, transition: mo, setStyles: _r, mutateDom: at, directive: pt, entangle: La, throttle: Ia, debounce: Oa, evaluate: de, initTree: Gt, nextTick: Qo, prefixed: Ie, prefix: Vl, plugin: $u, magic: Rt, store: Cu, start: Xl, clone: du, cloneNode: uu, bound: Su, $data: ta, watch: Wi, walk: me, data: Pu, bind: Tu }, dn = Iu; function Ha(t, e) { const n = Object.create(null), r = t.split(","); for (let o = 0; o < r.length; o++)n[r[o]] = !0; return e ? o => !!n[o.toLowerCase()] : o => !!n[o] } var Lu = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", yp = Ha(Lu + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), Mu = Object.freeze({}), wp = Object.freeze([]), Ru = Object.prototype.hasOwnProperty, yr = (t, e) => Ru.call(t, e), he = Array.isArray, Ye = t => Da(t) === "[object Map]", Nu = t => typeof t == "string", ns = t => typeof t == "symbol", wr = t => t !== null && typeof t == "object", Hu = Object.prototype.toString, Da = t => Hu.call(t), Ba = t => Da(t).slice(8, -1), rs = t => Nu(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, br = t => { const e = Object.create(null); return n => e[n] || (e[n] = t(n)) }, Du = /-(\w)/g, bp = br(t => t.replace(Du, (e, n) => n ? n.toUpperCase() : "")), Bu = /\B([A-Z])/g, xp = br(t => t.replace(Bu, "-$1").toLowerCase()), ja = br(t => t.charAt(0).toUpperCase() + t.slice(1)), Sp = br(t => t ? `on${ja(t)}` : ""), qa = (t, e) => t !== e && (t === t || e === e), _o = new WeakMap, Ue = [], Dt, fe = Symbol("iterate"), vo = Symbol("Map key iterate"); function ju(t) { return t && t._isEffect === !0 } function qu(t, e = Mu) { ju(t) && (t = t.raw); const n = Vu(t, e); return e.lazy || n(), n } function Fu(t) { t.active && (Fa(t), t.options.onStop && t.options.onStop(), t.active = !1) } var zu = 0; function Vu(t, e) { const n = function () { if (!n.active) return t(); if (!Ue.includes(n)) { Fa(n); try { return Wu(), Ue.push(n), Dt = n, t() } finally { Ue.pop(), za(), Dt = Ue[Ue.length - 1] } } }; return n.id = zu++, n.allowRecurse = !!e.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = t, n.deps = [], n.options = e, n } function Fa(t) { const { deps: e } = t; if (e.length) { for (let n = 0; n < e.length; n++)e[n].delete(t); e.length = 0 } } var Ce = !0, os = []; function Uu() { os.push(Ce), Ce = !1 } function Wu() { os.push(Ce), Ce = !0 } function za() { const t = os.pop(); Ce = t === void 0 ? !0 : t } function It(t, e, n) { if (!Ce || Dt === void 0) return; let r = _o.get(t); r || _o.set(t, r = new Map); let o = r.get(n); o || r.set(n, o = new Set), o.has(Dt) || (o.add(Dt), Dt.deps.push(o), Dt.options.onTrack && Dt.options.onTrack({ effect: Dt, target: t, type: e, key: n })) } function ee(t, e, n, r, o, s) { const i = _o.get(t); if (!i) return; const a = new Set, c = u => { u && u.forEach(d => { (d !== Dt || d.allowRecurse) && a.add(d) }) }; if (e === "clear") i.forEach(c); else if (n === "length" && he(t)) i.forEach((u, d) => { (d === "length" || d >= r) && c(u) }); else switch (n !== void 0 && c(i.get(n)), e) { case "add": he(t) ? rs(n) && c(i.get("length")) : (c(i.get(fe)), Ye(t) && c(i.get(vo))); break; case "delete": he(t) || (c(i.get(fe)), Ye(t) && c(i.get(vo))); break; case "set": Ye(t) && c(i.get(fe)); break }const l = u => { u.options.onTrigger && u.options.onTrigger({ effect: u, target: t, key: n, type: e, newValue: r, oldValue: o, oldTarget: s }), u.options.scheduler ? u.options.scheduler(u) : u() }; a.forEach(l) } var Ku = Ha("__proto__,__v_isRef,__isVue"), Va = new Set(Object.getOwnPropertyNames(Symbol).map(t => Symbol[t]).filter(ns)), Gu = Ua(), Zu = Ua(!0), Fs = Xu(); function Xu() { const t = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(e => { t[e] = function (...n) { const r = ot(this); for (let s = 0, i = this.length; s < i; s++)It(r, "get", s + ""); const o = r[e](...n); return o === -1 || o === !1 ? r[e](...n.map(ot)) : o } }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => { t[e] = function (...n) { Uu(); const r = ot(this)[e].apply(this, n); return za(), r } }), t } function Ua(t = !1, e = !1) { return function (r, o, s) { if (o === "__v_isReactive") return !t; if (o === "__v_isReadonly") return t; if (o === "__v_raw" && s === (t ? e ? hd : Za : e ? dd : Ga).get(r)) return r; const i = he(r); if (!t && i && yr(Fs, o)) return Reflect.get(Fs, o, s); const a = Reflect.get(r, o, s); return (ns(o) ? Va.has(o) : Ku(o)) || (t || It(r, "get", o), e) ? a : yo(a) ? !i || !rs(o) ? a.value : a : wr(a) ? t ? Xa(a) : cs(a) : a } } var Yu = Ju(); function Ju(t = !1) { return function (n, r, o, s) { let i = n[r]; if (!t && (o = ot(o), i = ot(i), !he(n) && yo(i) && !yo(o))) return i.value = o, !0; const a = he(n) && rs(r) ? Number(r) < n.length : yr(n, r), c = Reflect.set(n, r, o, s); return n === ot(s) && (a ? qa(o, i) && ee(n, "set", r, o, i) : ee(n, "add", r, o)), c } } function Qu(t, e) { const n = yr(t, e), r = t[e], o = Reflect.deleteProperty(t, e); return o && n && ee(t, "delete", e, void 0, r), o } function td(t, e) { const n = Reflect.has(t, e); return (!ns(e) || !Va.has(e)) && It(t, "has", e), n } function ed(t) { return It(t, "iterate", he(t) ? "length" : fe), Reflect.ownKeys(t) } var nd = { get: Gu, set: Yu, deleteProperty: Qu, has: td, ownKeys: ed }, rd = { get: Zu, set(t, e) { return console.warn(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0 }, deleteProperty(t, e) { return console.warn(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0 } }, ss = t => wr(t) ? cs(t) : t, is = t => wr(t) ? Xa(t) : t, as = t => t, xr = t => Reflect.getPrototypeOf(t); function Cn(t, e, n = !1, r = !1) { t = t.__v_raw; const o = ot(t), s = ot(e); e !== s && !n && It(o, "get", e), !n && It(o, "get", s); const { has: i } = xr(o), a = r ? as : n ? is : ss; if (i.call(o, e)) return a(t.get(e)); if (i.call(o, s)) return a(t.get(s)); t !== o && t.get(e) } function An(t, e = !1) { const n = this.__v_raw, r = ot(n), o = ot(t); return t !== o && !e && It(r, "has", t), !e && It(r, "has", o), t === o ? n.has(t) : n.has(t) || n.has(o) } function Tn(t, e = !1) { return t = t.__v_raw, !e && It(ot(t), "iterate", fe), Reflect.get(t, "size", t) } function zs(t) { t = ot(t); const e = ot(this); return xr(e).has.call(e, t) || (e.add(t), ee(e, "add", t, t)), this } function Vs(t, e) { e = ot(e); const n = ot(this), { has: r, get: o } = xr(n); let s = r.call(n, t); s ? Ka(n, r, t) : (t = ot(t), s = r.call(n, t)); const i = o.call(n, t); return n.set(t, e), s ? qa(e, i) && ee(n, "set", t, e, i) : ee(n, "add", t, e), this } function Us(t) { const e = ot(this), { has: n, get: r } = xr(e); let o = n.call(e, t); o ? Ka(e, n, t) : (t = ot(t), o = n.call(e, t)); const s = r ? r.call(e, t) : void 0, i = e.delete(t); return o && ee(e, "delete", t, void 0, s), i } function Ws() { const t = ot(this), e = t.size !== 0, n = Ye(t) ? new Map(t) : new Set(t), r = t.clear(); return e && ee(t, "clear", void 0, void 0, n), r } function kn(t, e) { return function (r, o) { const s = this, i = s.__v_raw, a = ot(i), c = e ? as : t ? is : ss; return !t && It(a, "iterate", fe), i.forEach((l, u) => r.call(o, c(l), c(u), s)) } } function Pn(t, e, n) { return function (...r) { const o = this.__v_raw, s = ot(o), i = Ye(s), a = t === "entries" || t === Symbol.iterator && i, c = t === "keys" && i, l = o[t](...r), u = n ? as : e ? is : ss; return !e && It(s, "iterate", c ? vo : fe), { next() { const { value: d, done: f } = l.next(); return f ? { value: d, done: f } : { value: a ? [u(d[0]), u(d[1])] : u(d), done: f } }, [Symbol.iterator]() { return this } } } } function Yt(t) { return function (...e) { { const n = e[0] ? `on key "${e[0]}" ` : ""; console.warn(`${ja(t)} operation ${n}failed: target is readonly.`, ot(this)) } return t === "delete" ? !1 : this } } function od() { const t = { get(s) { return Cn(this, s) }, get size() { return Tn(this) }, has: An, add: zs, set: Vs, delete: Us, clear: Ws, forEach: kn(!1, !1) }, e = { get(s) { return Cn(this, s, !1, !0) }, get size() { return Tn(this) }, has: An, add: zs, set: Vs, delete: Us, clear: Ws, forEach: kn(!1, !0) }, n = { get(s) { return Cn(this, s, !0) }, get size() { return Tn(this, !0) }, has(s) { return An.call(this, s, !0) }, add: Yt("add"), set: Yt("set"), delete: Yt("delete"), clear: Yt("clear"), forEach: kn(!0, !1) }, r = { get(s) { return Cn(this, s, !0, !0) }, get size() { return Tn(this, !0) }, has(s) { return An.call(this, s, !0) }, add: Yt("add"), set: Yt("set"), delete: Yt("delete"), clear: Yt("clear"), forEach: kn(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(s => { t[s] = Pn(s, !1, !1), n[s] = Pn(s, !0, !1), e[s] = Pn(s, !1, !0), r[s] = Pn(s, !0, !0) }), [t, n, e, r] } var [sd, id, ad, cd] = od(); function Wa(t, e) { const n = e ? t ? cd : ad : t ? id : sd; return (r, o, s) => o === "__v_isReactive" ? !t : o === "__v_isReadonly" ? t : o === "__v_raw" ? r : Reflect.get(yr(n, o) && o in r ? n : r, o, s) } var ld = { get: Wa(!1, !1) }, ud = { get: Wa(!0, !1) }; function Ka(t, e, n) { const r = ot(n); if (r !== n && e.call(t, r)) { const o = Ba(t); console.warn(`Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } var Ga = new WeakMap, dd = new WeakMap, Za = new WeakMap, hd = new WeakMap; function fd(t) { switch (t) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function pd(t) { return t.__v_skip || !Object.isExtensible(t) ? 0 : fd(Ba(t)) } function cs(t) { return t && t.__v_isReadonly ? t : Ya(t, !1, nd, ld, Ga) } function Xa(t) { return Ya(t, !0, rd, ud, Za) } function Ya(t, e, n, r, o) { if (!wr(t)) return console.warn(`value cannot be made reactive: ${String(t)}`), t; if (t.__v_raw && !(e && t.__v_isReactive)) return t; const s = o.get(t); if (s) return s; const i = pd(t); if (i === 0) return t; const a = new Proxy(t, i === 2 ? r : n); return o.set(t, a), a } function ot(t) { return t && ot(t.__v_raw) || t } function yo(t) { return !!(t && t.__v_isRef === !0) } Rt("nextTick", () => Qo); Rt("dispatch", t => Xe.bind(Xe, t)); Rt("watch", (t, { evaluateLater: e, cleanup: n }) => (r, o) => { let s = e(r), a = Wi(() => { let c; return s(l => c = l), c }, o); n(a) }); Rt("store", Au); Rt("data", t => ta(t)); Rt("root", t => gr(t)); Rt("refs", t => (t._x_refs_proxy || (t._x_refs_proxy = un(md(t))), t._x_refs_proxy)); function md(t) { let e = []; return Le(t, n => { n._x_refs && e.push(n._x_refs) }), e } var Ur = {}; function Ja(t) { return Ur[t] || (Ur[t] = 0), ++Ur[t] } function gd(t, e) { return Le(t, n => { if (n._x_ids && n._x_ids[e]) return !0 }) } function _d(t, e) { t._x_ids || (t._x_ids = {}), t._x_ids[e] || (t._x_ids[e] = Ja(e)) } Rt("id", (t, { cleanup: e }) => (n, r = null) => { let o = `${n}${r ? `-${r}` : ""}`; return vd(t, o, e, () => { let s = gd(t, n), i = s ? s._x_ids[n] : Ja(n); return r ? `${n}-${i}-${r}` : `${n}-${i}` }) }); vr((t, e) => { t._x_id && (e._x_id = t._x_id) }); function vd(t, e, n, r) { if (t._x_id || (t._x_id = {}), t._x_id[e]) return t._x_id[e]; let o = r(); return t._x_id[e] = o, n(() => { delete t._x_id[e] }), o } Rt("el", t => t); Qa("Focus", "focus", "focus"); Qa("Persist", "persist", "persist"); function Qa(t, e, n) { Rt(e, r => kt(`You can't use [$${e}] without first installing the "${t}" plugin here: https://alpinejs.dev/plugins/${n}`, r)) } pt("modelable", (t, { expression: e }, { effect: n, evaluateLater: r, cleanup: o }) => { let s = r(e), i = () => { let u; return s(d => u = d), u }, a = r(`${e} = __placeholder`), c = u => a(() => { }, { scope: { __placeholder: u } }), l = i(); c(l), queueMicrotask(() => { if (!t._x_model) return; t._x_removeModelListeners.default(); let u = t._x_model.get, d = t._x_model.set, f = La({ get() { return u() }, set(m) { d(m) } }, { get() { return i() }, set(m) { c(m) } }); o(f) }) }); pt("teleport", (t, { modifiers: e, expression: n }, { cleanup: r }) => { t.tagName.toLowerCase() !== "template" && kt("x-teleport can only be used on a <template> tag", t); let o = Ks(n), s = t.content.cloneNode(!0).firstElementChild; t._x_teleport = s, s._x_teleportBack = t, t.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), t._x_forwardEvents && t._x_forwardEvents.forEach(a => { s.addEventListener(a, c => { c.stopPropagation(), t.dispatchEvent(new c.constructor(c.type, c)) }) }), ln(s, {}, t); let i = (a, c, l) => { l.includes("prepend") ? c.parentNode.insertBefore(a, c) : l.includes("append") ? c.parentNode.insertBefore(a, c.nextSibling) : c.appendChild(a) }; at(() => { i(s, o, e), ne(() => { Gt(s) })() }), t._x_teleportPutBack = () => { let a = Ks(n); at(() => { i(t._x_teleport, a, e) }) }, r(() => at(() => { s.remove(), Me(s) })) }); var yd = document.createElement("div"); function Ks(t) { let e = ne(() => document.querySelector(t), () => yd)(); return e || kt(`Cannot find x-teleport element for selector: "${t}"`), e } var tc = () => { }; tc.inline = (t, { modifiers: e }, { cleanup: n }) => { e.includes("self") ? t._x_ignoreSelf = !0 : t._x_ignore = !0, n(() => { e.includes("self") ? delete t._x_ignoreSelf : delete t._x_ignore }) }; pt("ignore", tc); pt("effect", ne((t, { expression: e }, { effect: n }) => { n(bt(t, e)) })); function wo(t, e, n, r) { let o = t, s = c => r(c), i = {}, a = (c, l) => u => l(c, u); if (n.includes("dot") && (e = wd(e)), n.includes("camel") && (e = bd(e)), n.includes("passive") && (i.passive = !0), n.includes("capture") && (i.capture = !0), n.includes("window") && (o = window), n.includes("document") && (o = document), n.includes("debounce")) { let c = n[n.indexOf("debounce") + 1] || "invalid-wait", l = tr(c.split("ms")[0]) ? Number(c.split("ms")[0]) : 250; s = Oa(s, l) } if (n.includes("throttle")) { let c = n[n.indexOf("throttle") + 1] || "invalid-wait", l = tr(c.split("ms")[0]) ? Number(c.split("ms")[0]) : 250; s = Ia(s, l) } return n.includes("prevent") && (s = a(s, (c, l) => { l.preventDefault(), c(l) })), n.includes("stop") && (s = a(s, (c, l) => { l.stopPropagation(), c(l) })), n.includes("once") && (s = a(s, (c, l) => { c(l), o.removeEventListener(e, s, i) })), (n.includes("away") || n.includes("outside")) && (o = document, s = a(s, (c, l) => { t.contains(l.target) || l.target.isConnected !== !1 && (t.offsetWidth < 1 && t.offsetHeight < 1 || t._x_isShown !== !1 && c(l)) })), n.includes("self") && (s = a(s, (c, l) => { l.target === t && c(l) })), (Sd(e) || ec(e)) && (s = a(s, (c, l) => { Ed(l, n) || c(l) })), o.addEventListener(e, s, i), () => { o.removeEventListener(e, s, i) } } function wd(t) { return t.replace(/-/g, ".") } function bd(t) { return t.toLowerCase().replace(/-(\w)/g, (e, n) => n.toUpperCase()) } function tr(t) { return !Array.isArray(t) && !isNaN(t) } function xd(t) { return [" ", "_"].includes(t) ? t : t.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase() } function Sd(t) { return ["keydown", "keyup"].includes(t) } function ec(t) { return ["contextmenu", "click", "mouse"].some(e => t.includes(e)) } function Ed(t, e) { let n = e.filter(s => !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(s)); if (n.includes("debounce")) { let s = n.indexOf("debounce"); n.splice(s, tr((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (n.includes("throttle")) { let s = n.indexOf("throttle"); n.splice(s, tr((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (n.length === 0 || n.length === 1 && Gs(t.key).includes(n[0])) return !1; const o = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter(s => n.includes(s)); return n = n.filter(s => !o.includes(s)), !(o.length > 0 && o.filter(i => ((i === "cmd" || i === "super") && (i = "meta"), t[`${i}Key`])).length === o.length && (ec(t.type) || Gs(t.key).includes(n[0]))) } function Gs(t) { if (!t) return []; t = xd(t); let e = { ctrl: "control", slash: "/", space: " ", spacebar: " ", cmd: "meta", esc: "escape", up: "arrow-up", down: "arrow-down", left: "arrow-left", right: "arrow-right", period: ".", comma: ",", equal: "=", minus: "-", underscore: "_" }; return e[t] = t, Object.keys(e).map(n => { if (e[n] === t) return n }).filter(n => n) } pt("model", (t, { modifiers: e, expression: n }, { effect: r, cleanup: o }) => { let s = t; e.includes("parent") && (s = t.parentNode); let i = bt(s, n), a; typeof n == "string" ? a = bt(s, `${n} = __placeholder`) : typeof n == "function" && typeof n() == "string" ? a = bt(s, `${n()} = __placeholder`) : a = () => { }; let c = () => { let f; return i(m => f = m), Zs(f) ? f.get() : f }, l = f => { let m; i(h => m = h), Zs(m) ? m.set(f) : a(() => { }, { scope: { __placeholder: f } }) }; typeof n == "string" && t.type === "radio" && at(() => { t.hasAttribute("name") || t.setAttribute("name", n) }); var u = t.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(t.type) || e.includes("lazy") ? "change" : "input"; let d = te ? () => { } : wo(t, u, e, f => { l(Wr(t, e, f, c())) }); if (e.includes("fill") && ([void 0, null, ""].includes(c()) || es(t) && Array.isArray(c()) || t.tagName.toLowerCase() === "select" && t.multiple) && l(Wr(t, e, { target: t }, c())), t._x_removeModelListeners || (t._x_removeModelListeners = {}), t._x_removeModelListeners.default = d, o(() => t._x_removeModelListeners.default()), t.form) { let f = wo(t.form, "reset", [], m => { Qo(() => t._x_model && t._x_model.set(Wr(t, e, { target: t }, c()))) }); o(() => f()) } t._x_model = { get() { return c() }, set(f) { l(f) } }, t._x_forceModelUpdate = f => { f === void 0 && typeof n == "string" && n.match(/\./) && (f = ""), window.fromModel = !0, at(() => Ca(t, "value", f)), delete window.fromModel }, r(() => { let f = c(); e.includes("unintrusive") && document.activeElement.isSameNode(t) || t._x_forceModelUpdate(f) }) }); function Wr(t, e, n, r) { return at(() => { if (n instanceof CustomEvent && n.detail !== void 0) return n.detail !== null && n.detail !== void 0 ? n.detail : n.target.value; if (es(t)) if (Array.isArray(r)) { let o = null; return e.includes("number") ? o = Kr(n.target.value) : e.includes("boolean") ? o = Fn(n.target.value) : o = n.target.value, n.target.checked ? r.includes(o) ? r : r.concat([o]) : r.filter(s => !$d(s, o)) } else return n.target.checked; else { if (t.tagName.toLowerCase() === "select" && t.multiple) return e.includes("number") ? Array.from(n.target.selectedOptions).map(o => { let s = o.value || o.text; return Kr(s) }) : e.includes("boolean") ? Array.from(n.target.selectedOptions).map(o => { let s = o.value || o.text; return Fn(s) }) : Array.from(n.target.selectedOptions).map(o => o.value || o.text); { let o; return Pa(t) ? n.target.checked ? o = n.target.value : o = r : o = n.target.value, e.includes("number") ? Kr(o) : e.includes("boolean") ? Fn(o) : e.includes("trim") ? o.trim() : o } } }) } function Kr(t) { let e = t ? parseFloat(t) : null; return Cd(e) ? e : t } function $d(t, e) { return t == e } function Cd(t) { return !Array.isArray(t) && !isNaN(t) } function Zs(t) { return t !== null && typeof t == "object" && typeof t.get == "function" && typeof t.set == "function" } pt("cloak", t => queueMicrotask(() => at(() => t.removeAttribute(Ie("cloak"))))); wa(() => `[${Ie("init")}]`); pt("init", ne((t, { expression: e }, { evaluate: n }) => typeof e == "string" ? !!e.trim() && n(e, {}, !1) : n(e, {}, !1))); pt("text", (t, { expression: e }, { effect: n, evaluateLater: r }) => { let o = r(e); n(() => { o(s => { at(() => { t.textContent = s }) }) }) }); pt("html", (t, { expression: e }, { effect: n, evaluateLater: r }) => { let o = r(e); n(() => { o(s => { at(() => { t.innerHTML = s, t._x_ignoreSelf = !0, Gt(t), delete t._x_ignoreSelf }) }) }) }); Xo(ua(":", da(Ie("bind:")))); var nc = (t, { value: e, modifiers: n, expression: r, original: o }, { effect: s, cleanup: i }) => { if (!e) { let c = {}; ku(c), bt(t, r)(u => { Ra(t, u, o) }, { scope: c }); return } if (e === "key") return Ad(t, r); if (t._x_inlineBindings && t._x_inlineBindings[e] && t._x_inlineBindings[e].extract) return; let a = bt(t, r); s(() => a(c => { c === void 0 && typeof r == "string" && r.match(/\./) && (c = ""), at(() => Ca(t, e, c, n)) })), i(() => { t._x_undoAddedClasses && t._x_undoAddedClasses(), t._x_undoAddedStyles && t._x_undoAddedStyles() }) }; nc.inline = (t, { value: e, modifiers: n, expression: r }) => { e && (t._x_inlineBindings || (t._x_inlineBindings = {}), t._x_inlineBindings[e] = { expression: r, extract: !1 }) }; pt("bind", nc); function Ad(t, e) { t._x_keyExpression = e } ya(() => `[${Ie("data")}]`); pt("data", (t, { expression: e }, { cleanup: n }) => { if (Td(t)) return; e = e === "" ? "{}" : e; let r = {}; co(r, t); let o = {}; Ou(o, r); let s = de(t, e, { scope: o }); (s === void 0 || s === !0) && (s = {}), co(s, t); let i = Pe(s); ea(i); let a = ln(t, i); i.init && de(t, i.init), n(() => { i.destroy && de(t, i.destroy), a() }) }); vr((t, e) => { t._x_dataStack && (e._x_dataStack = t._x_dataStack, e.setAttribute("data-has-alpine-state", !0)) }); function Td(t) { return te ? go ? !0 : t.hasAttribute("data-has-alpine-state") : !1 } pt("show", (t, { modifiers: e, expression: n }, { effect: r }) => { let o = bt(t, n); t._x_doHide || (t._x_doHide = () => { at(() => { t.style.setProperty("display", "none", e.includes("important") ? "important" : void 0) }) }), t._x_doShow || (t._x_doShow = () => { at(() => { t.style.length === 1 && t.style.display === "none" ? t.removeAttribute("style") : t.style.removeProperty("display") }) }); let s = () => { t._x_doHide(), t._x_isShown = !1 }, i = () => { t._x_doShow(), t._x_isShown = !0 }, a = () => setTimeout(i), c = po(d => d ? i() : s(), d => { typeof t._x_toggleAndCascadeWithTransitions == "function" ? t._x_toggleAndCascadeWithTransitions(t, d, i, s) : d ? a() : s() }), l, u = !0; r(() => o(d => { !u && d === l || (e.includes("immediate") && (d ? a() : s()), c(d), l = d, u = !1) })) }); pt("for", (t, { expression: e }, { effect: n, cleanup: r }) => { let o = Pd(e), s = bt(t, o.items), i = bt(t, t._x_keyExpression || "index"); t._x_prevKeys = [], t._x_lookup = {}, n(() => kd(t, o, s, i)), r(() => { Object.values(t._x_lookup).forEach(a => at(() => { Me(a), a.remove() })), delete t._x_prevKeys, delete t._x_lookup }) }); function kd(t, e, n, r) { let o = i => typeof i == "object" && !Array.isArray(i), s = t; n(i => { Od(i) && i >= 0 && (i = Array.from(Array(i).keys(), p => p + 1)), i === void 0 && (i = []); let a = t._x_lookup, c = t._x_prevKeys, l = [], u = []; if (o(i)) i = Object.entries(i).map(([p, g]) => { let v = Xs(e, g, p, i); r(b => { u.includes(b) && kt("Duplicate key on x-for", t), u.push(b) }, { scope: { index: p, ...v } }), l.push(v) }); else for (let p = 0; p < i.length; p++) { let g = Xs(e, i[p], p, i); r(v => { u.includes(v) && kt("Duplicate key on x-for", t), u.push(v) }, { scope: { index: p, ...g } }), l.push(g) } let d = [], f = [], m = [], h = []; for (let p = 0; p < c.length; p++) { let g = c[p]; u.indexOf(g) === -1 && m.push(g) } c = c.filter(p => !m.includes(p)); let _ = "template"; for (let p = 0; p < u.length; p++) { let g = u[p], v = c.indexOf(g); if (v === -1) c.splice(p, 0, g), d.push([_, p]); else if (v !== p) { let b = c.splice(p, 1)[0], w = c.splice(v - 1, 1)[0]; c.splice(p, 0, w), c.splice(v, 0, b), f.push([b, w]) } else h.push(g); _ = g } for (let p = 0; p < m.length; p++) { let g = m[p]; g in a && (at(() => { Me(a[g]), a[g].remove() }), delete a[g]) } for (let p = 0; p < f.length; p++) { let [g, v] = f[p], b = a[g], w = a[v], k = document.createElement("div"); at(() => { w || kt('x-for ":key" is undefined or invalid', s, v, a), w.after(k), b.after(w), w._x_currentIfEl && w.after(w._x_currentIfEl), k.before(b), b._x_currentIfEl && b.after(b._x_currentIfEl), k.remove() }), w._x_refreshXForScope(l[u.indexOf(v)]) } for (let p = 0; p < d.length; p++) { let [g, v] = d[p], b = g === "template" ? s : a[g]; b._x_currentIfEl && (b = b._x_currentIfEl); let w = l[v], k = u[v], P = document.importNode(s.content, !0).firstElementChild, M = Pe(w); ln(P, M, s), P._x_refreshXForScope = j => { Object.entries(j).forEach(([O, E]) => { M[O] = E }) }, at(() => { b.after(P), ne(() => Gt(P))() }), typeof k == "object" && kt("x-for key cannot be an object, it must be a string or an integer", s), a[k] = P } for (let p = 0; p < h.length; p++)a[h[p]]._x_refreshXForScope(l[u.indexOf(h[p])]); s._x_prevKeys = u }) } function Pd(t) { let e = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = /^\s*\(|\)\s*$/g, r = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, o = t.match(r); if (!o) return; let s = {}; s.items = o[2].trim(); let i = o[1].replace(n, "").trim(), a = i.match(e); return a ? (s.item = i.replace(e, "").trim(), s.index = a[1].trim(), a[2] && (s.collection = a[2].trim())) : s.item = i, s } function Xs(t, e, n, r) { let o = {}; return /^\[.*\]$/.test(t.item) && Array.isArray(e) ? t.item.replace("[", "").replace("]", "").split(",").map(i => i.trim()).forEach((i, a) => { o[i] = e[a] }) : /^\{.*\}$/.test(t.item) && !Array.isArray(e) && typeof e == "object" ? t.item.replace("{", "").replace("}", "").split(",").map(i => i.trim()).forEach(i => { o[i] = e[i] }) : o[t.item] = e, t.index && (o[t.index] = n), t.collection && (o[t.collection] = r), o } function Od(t) { return !Array.isArray(t) && !isNaN(t) } function rc() { } rc.inline = (t, { expression: e }, { cleanup: n }) => { let r = gr(t); r._x_refs || (r._x_refs = {}), r._x_refs[e] = t, n(() => delete r._x_refs[e]) }; pt("ref", rc); pt("if", (t, { expression: e }, { effect: n, cleanup: r }) => { t.tagName.toLowerCase() !== "template" && kt("x-if can only be used on a <template> tag", t); let o = bt(t, e), s = () => { if (t._x_currentIfEl) return t._x_currentIfEl; let a = t.content.cloneNode(!0).firstElementChild; return ln(a, {}, t), at(() => { t.after(a), ne(() => Gt(a))() }), t._x_currentIfEl = a, t._x_undoIf = () => { at(() => { Me(a), a.remove() }), delete t._x_currentIfEl }, a }, i = () => { t._x_undoIf && (t._x_undoIf(), delete t._x_undoIf) }; n(() => o(a => { a ? s() : i() })), r(() => t._x_undoIf && t._x_undoIf()) }); pt("id", (t, { expression: e }, { evaluate: n }) => { n(e).forEach(o => _d(t, o)) }); vr((t, e) => { t._x_ids && (e._x_ids = t._x_ids) }); Xo(ua("@", da(Ie("on:")))); pt("on", ne((t, { value: e, modifiers: n, expression: r }, { cleanup: o }) => { let s = r ? bt(t, r) : () => { }; t.tagName.toLowerCase() === "template" && (t._x_forwardEvents || (t._x_forwardEvents = []), t._x_forwardEvents.includes(e) || t._x_forwardEvents.push(e)); let i = wo(t, e, n, a => { s(() => { }, { scope: { $event: a }, params: [a] }) }); o(() => i()) })); Sr("Collapse", "collapse", "collapse"); Sr("Intersect", "intersect", "intersect"); Sr("Focus", "trap", "focus"); Sr("Mask", "mask", "mask"); function Sr(t, e, n) { pt(e, r => kt(`You can't use [x-${e}] without first installing the "${t}" plugin here: https://alpinejs.dev/plugins/${n}`, r)) } dn.setEvaluator(ia); dn.setReactivityEngine({ reactive: cs, effect: qu, release: Fu, raw: ot }); var Id = dn, re = Id; const Gr = new WeakMap; function Zr(t, e, n, r) { if (!t && !Gr.has(e)) return !1; const o = Gr.get(e) ?? new WeakMap; Gr.set(e, o); const s = o.get(n) ?? new Set; o.set(n, s); const i = s.has(r); return t ? s.add(r) : s.delete(r), i && t } function Ld(t, e) { let n = t.target; if (n instanceof Text && (n = n.parentElement), n instanceof Element && t.currentTarget instanceof Element) { const r = n.closest(e); if (r && t.currentTarget.contains(r)) return r } } function Md(t, e, n, r = {}) { const { signal: o, base: s = document } = r; if (o?.aborted) return; const { once: i, ...a } = r, c = s instanceof Document ? s.documentElement : s, l = !!(typeof r == "object" ? r.capture : r), u = m => { const h = Ld(m, String(t)); if (h) { const _ = Object.assign(m, { delegateTarget: h }); n.call(c, _), i && (c.removeEventListener(e, u, a), Zr(!1, c, n, d)) } }, d = JSON.stringify({ selector: t, type: e, capture: l }); Zr(!0, c, n, d) || c.addEventListener(e, u, a), o?.addEventListener("abort", () => { Zr(!1, c, n, d) }) } function gt() { return gt = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, gt.apply(null, arguments) } const oc = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "", ge = ({ hash: t } = {}) => window.location.pathname + window.location.search + (t ? window.location.hash : ""), Rd = (t, e = {}) => { const n = gt({ url: t = t || ge({ hash: !0 }), random: Math.random(), source: "swup" }, e); window.history.pushState(n, "", t) }, Je = (t = null, e = {}) => { t = t || ge({ hash: !0 }); const n = gt({}, window.history.state || {}, { url: t, random: Math.random(), source: "swup" }, e); window.history.replaceState(n, "", t) }, Nd = (t, e, n, r) => { const o = new AbortController; return r = gt({}, r, { signal: o.signal }), Md(t, e, n, r), { destroy: () => o.abort() } }; let vt = class zn extends URL { constructor(e, n = document.baseURI) { super(e.toString(), n), Object.setPrototypeOf(this, zn.prototype) } get url() { return this.pathname + this.search } static fromElement(e) { const n = e.getAttribute("href") || e.getAttribute("xlink:href") || ""; return new zn(n) } static fromUrl(e) { return new zn(e) } }; let On = class extends Error { constructor(e, n) { super(e), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = n.url, this.status = n.status, this.aborted = n.aborted || !1, this.timedOut = n.timedOut || !1 } }; async function Hd(t, e = {}) { var n; t = vt.fromUrl(t).url; const { visit: r = this.visit } = e, o = gt({}, this.options.requestHeaders, e.headers), s = (n = e.timeout) != null ? n : this.options.timeout, i = new AbortController, { signal: a } = i; e = gt({}, e, { headers: o, signal: a }); let c, l = !1, u = null; s && s > 0 && (u = setTimeout(() => { l = !0, i.abort("timeout") }, s)); try { c = await this.hooks.call("fetch:request", r, { url: t, options: e }, (p, { url: g, options: v }) => fetch(g, v)), u && clearTimeout(u) } catch (p) { throw l ? (this.hooks.call("fetch:timeout", r, { url: t }), new On(`Request timed out: ${t}`, { url: t, timedOut: l })) : p?.name === "AbortError" || a.aborted ? new On(`Request aborted: ${t}`, { url: t, aborted: !0 }) : p } const { status: d, url: f } = c, m = await c.text(); if (d === 500) throw this.hooks.call("fetch:error", r, { status: d, response: c, url: f }), new On(`Server error: ${f}`, { status: d, url: f }); if (!m) throw new On(`Empty response: ${f}`, { status: d, url: f }); const { url: h } = vt.fromUrl(f), _ = { url: h, html: m }; return !r.cache.write || e.method && e.method !== "GET" || t !== h || this.cache.set(_.url, _), _ } let Dd = class { constructor(e) { this.swup = void 0, this.pages = new Map, this.swup = e } get size() { return this.pages.size } get all() { const e = new Map; return this.pages.forEach((n, r) => { e.set(r, gt({}, n)) }), e } has(e) { return this.pages.has(this.resolve(e)) } get(e) { const n = this.pages.get(this.resolve(e)); return n && gt({}, n) } set(e, n) { n = gt({}, n, { url: e = this.resolve(e) }), this.pages.set(e, n), this.swup.hooks.callSync("cache:set", void 0, { page: n }) } update(e, n) { e = this.resolve(e); const r = gt({}, this.get(e), n, { url: e }); this.pages.set(e, r) } delete(e) { this.pages.delete(this.resolve(e)) } clear() { this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0) } prune(e) { this.pages.forEach((n, r) => { e(r, n) && this.delete(r) }) } resolve(e) { const { url: n } = vt.fromUrl(e); return this.swup.resolveUrl(n) } }; const bo = (t, e = document) => e.querySelector(t), ls = (t, e = document) => Array.from(e.querySelectorAll(t)), sc = () => new Promise(t => { requestAnimationFrame(() => { requestAnimationFrame(() => { t() }) }) }); function ic(t) { return !!t && (typeof t == "object" || typeof t == "function") && typeof t.then == "function" } function Bd(t, e = []) { return new Promise((n, r) => { const o = t(...e); ic(o) ? o.then(n, r) : n(o) }) } function Ys(t, e) { const n = t?.closest(`[${e}]`); return n != null && n.hasAttribute(e) ? n?.getAttribute(e) || !0 : void 0 } let jd = class { constructor(e) { this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = e } get selectors() { const { scope: e } = this.swup.visit.animation; return e === "containers" ? this.swup.visit.containers : e === "html" ? ["html"] : Array.isArray(e) ? e : [] } get selector() { return this.selectors.join(",") } get targets() { return this.selector.trim() ? ls(this.selector) : [] } add(...e) { this.targets.forEach(n => n.classList.add(...e)) } remove(...e) { this.targets.forEach(n => n.classList.remove(...e)) } clear() { this.targets.forEach(e => { const n = e.className.split(" ").filter(r => this.isSwupClass(r)); e.classList.remove(...n) }) } isSwupClass(e) { return this.swupClasses.some(n => e.startsWith(n)) } }, ac = class { constructor(e, n) { this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0, this.meta = void 0; const { to: r, from: o, hash: s, el: i, event: a } = n; this.id = Math.random(), this.state = 1, this.from = { url: o ?? e.location.url, hash: e.location.hash }, this.to = { url: r, hash: s }, this.containers = e.options.containers, this.animation = { animate: !0, wait: !1, name: void 0, native: e.options.native, scope: e.options.animationScope, selector: e.options.animationSelector }, this.trigger = { el: i, event: a }, this.cache = { read: e.options.cache, write: e.options.cache }, this.history = { action: "push", popstate: !1, direction: void 0 }, this.scroll = { reset: !0, target: void 0 }, this.meta = {} } advance(e) { this.state < e && (this.state = e) } abort() { this.state = 8 } get done() { return this.state >= 7 } }; function qd(t) { return new ac(this, t) } let Fd = class { constructor(e) { this.swup = void 0, this.registry = new Map, this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = e, this.init() } init() { this.hooks.forEach(e => this.create(e)) } create(e) { this.registry.has(e) || this.registry.set(e, new Map) } exists(e) { return this.registry.has(e) } get(e) { const n = this.registry.get(e); if (n) return n; console.error(`Unknown hook '${e}'`) } clear() { this.registry.forEach(e => e.clear()) } on(e, n, r = {}) { const o = this.get(e); if (!o) return console.warn(`Hook '${e}' not found.`), () => { }; const s = gt({}, r, { id: o.size + 1, hook: e, handler: n }); return o.set(n, s), () => this.off(e, n) } before(e, n, r = {}) { return this.on(e, n, gt({}, r, { before: !0 })) } replace(e, n, r = {}) { return this.on(e, n, gt({}, r, { replace: !0 })) } once(e, n, r = {}) { return this.on(e, n, gt({}, r, { once: !0 })) } off(e, n) { const r = this.get(e); r && n ? r.delete(n) || console.warn(`Handler for hook '${e}' not found.`) : r && r.clear() } async call(e, n, r, o) { const [s, i, a] = this.parseCallArgs(e, n, r, o), { before: c, handler: l, after: u } = this.getHandlers(e, a); await this.run(c, s, i); const [d] = await this.run(l, s, i, !0); return await this.run(u, s, i), this.dispatchDomEvent(e, s, i), d } callSync(e, n, r, o) { const [s, i, a] = this.parseCallArgs(e, n, r, o), { before: c, handler: l, after: u } = this.getHandlers(e, a); this.runSync(c, s, i); const [d] = this.runSync(l, s, i, !0); return this.runSync(u, s, i), this.dispatchDomEvent(e, s, i), d } parseCallArgs(e, n, r, o) { return n instanceof ac || typeof n != "object" && typeof r != "function" ? [n, r, o] : [void 0, n, r] } async run(e, n = this.swup.visit, r, o = !1) { const s = []; for (const { hook: i, handler: a, defaultHandler: c, once: l } of e) if (n == null || !n.done) { l && this.off(i, a); try { const u = await Bd(a, [n, r, c]); s.push(u) } catch (u) { if (o) throw u; console.error(`Error in hook '${i}':`, u) } } return s } runSync(e, n = this.swup.visit, r, o = !1) { const s = []; for (const { hook: i, handler: a, defaultHandler: c, once: l } of e) if (n == null || !n.done) { l && this.off(i, a); try { const u = a(n, r, c); s.push(u), ic(u) && console.warn(`Swup will not await Promises in handler for synchronous hook '${i}'.`) } catch (u) { if (o) throw u; console.error(`Error in hook '${i}':`, u) } } return s } getHandlers(e, n) { const r = this.get(e); if (!r) return { found: !1, before: [], handler: [], after: [], replaced: !1 }; const o = Array.from(r.values()), s = this.sortRegistrations, i = o.filter(({ before: d, replace: f }) => d && !f).sort(s), a = o.filter(({ replace: d }) => d).filter(d => !0).sort(s), c = o.filter(({ before: d, replace: f }) => !d && !f).sort(s), l = a.length > 0; let u = []; if (n && (u = [{ id: 0, hook: e, handler: n }], l)) { const d = a.length - 1, { handler: f, once: m } = a[d], h = _ => { const p = a[_ - 1]; return p ? (g, v) => p.handler(g, v, h(_ - 1)) : n }; u = [{ id: 0, hook: e, once: m, handler: f, defaultHandler: h(d) }] } return { found: !0, before: i, handler: u, after: c, replaced: l } } sortRegistrations(e, n) { var r, o; return ((r = e.priority) != null ? r : 0) - ((o = n.priority) != null ? o : 0) || e.id - n.id || 0 } dispatchDomEvent(e, n, r) { if (n != null && n.done) return; const o = { hook: e, args: r, visit: n || this.swup.visit }; document.dispatchEvent(new CustomEvent("swup:any", { detail: o, bubbles: !0 })), document.dispatchEvent(new CustomEvent(`swup:${e}`, { detail: o, bubbles: !0 })) } parseName(e) { const [n, ...r] = e.split("."); return [n, r.reduce((o, s) => gt({}, o, { [s]: !0 }), {})] } }; const zd = t => { if (t && t.charAt(0) === "#" && (t = t.substring(1)), !t) return null; const e = decodeURIComponent(t); let n = document.getElementById(t) || document.getElementById(e) || bo(`a[name='${CSS.escape(t)}']`) || bo(`a[name='${CSS.escape(e)}']`); return n || t !== "top" || (n = document.body), n }, In = "transition", Xr = "animation"; async function Vd({ selector: t, elements: e }) { if (t === !1 && !e) return; let n = []; if (e) n = Array.from(e); else if (t && (n = ls(t, document.body), !n.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${t}\``); const r = n.map(o => (function (s) { const { type: i, timeout: a, propCount: c } = (function (l) { const u = window.getComputedStyle(l), d = Ln(u, `${In}Delay`), f = Ln(u, `${In}Duration`), m = Js(d, f), h = Ln(u, `${Xr}Delay`), _ = Ln(u, `${Xr}Duration`), p = Js(h, _), g = Math.max(m, p), v = g > 0 ? m > p ? In : Xr : null; return { type: v, timeout: g, propCount: v ? v === In ? f.length : _.length : 0 } })(s); return !(!i || !a) && new Promise(l => { const u = `${i}end`, d = performance.now(); let f = 0; const m = () => { s.removeEventListener(u, h), l() }, h = _ => { _.target === s && ((performance.now() - d) / 1e3 < _.elapsedTime || ++f >= c && m()) }; setTimeout(() => { f < c && m() }, a + 1), s.addEventListener(u, h) }) })(o)); r.filter(Boolean).length > 0 ? await Promise.all(r) : t && console.warn(`[swup] No CSS animation duration defined on elements matching \`${t}\``) } function Ln(t, e) { return (t[e] || "").split(", ") } function Js(t, e) { for (; t.length < e.length;)t = t.concat(t); return Math.max(...e.map((n, r) => Qs(n) + Qs(t[r]))) } function Qs(t) { return 1e3 * parseFloat(t) } function Ud(t, e = {}, n = {}) { if (typeof t != "string") throw new Error("swup.navigate() requires a URL parameter"); if (this.shouldIgnoreVisit(t, { el: n.el, event: n.event })) return void window.location.assign(t); const { url: r, hash: o } = vt.fromUrl(t), s = this.createVisit(gt({}, n, { to: r, hash: o })); this.performNavigation(s, e) } async function Wd(t, e = {}) { if (this.navigating) { if (this.visit.state >= 6) return t.state = 2, void (this.onVisitEnd = () => this.performNavigation(t, e)); await this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8 } this.navigating = !0, this.visit = t; const { el: n } = t.trigger; e.referrer = e.referrer || this.location.url, e.animate === !1 && (t.animation.animate = !1), t.animation.animate || this.classes.clear(); const r = e.history || Ys(n, "data-swup-history"); typeof r == "string" && ["push", "replace"].includes(r) && (t.history.action = r); const o = e.animation || Ys(n, "data-swup-animation"); var s, i; typeof o == "string" && (t.animation.name = o), t.meta = e.meta || {}, typeof e.cache == "object" ? (t.cache.read = (s = e.cache.read) != null ? s : t.cache.read, t.cache.write = (i = e.cache.write) != null ? i : t.cache.write) : e.cache !== void 0 && (t.cache = { read: !!e.cache, write: !!e.cache }), delete e.cache; try { await this.hooks.call("visit:start", t, void 0), t.state = 3; const a = this.hooks.call("page:load", t, { options: e }, async (l, u) => { let d; return l.cache.read && (d = this.cache.get(l.to.url)), u.page = d || await this.fetchPage(l.to.url, u.options), u.cache = !!d, u.page }); a.then(({ html: l }) => { t.advance(5), t.to.html = l, t.to.document = new DOMParser().parseFromString(l, "text/html") }); const c = t.to.url + t.to.hash; if (t.history.popstate || (t.history.action === "replace" || t.to.url === this.location.url ? Je(c) : (this.currentHistoryIndex++, Rd(c, { index: this.currentHistoryIndex }))), this.location = vt.fromUrl(c), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${oc(t.animation.name)}`), t.animation.wait && await a, t.done || (await this.hooks.call("visit:transition", t, void 0, async () => { if (!t.animation.animate) return await this.hooks.call("animation:skip", void 0), void await this.renderPage(t, await a); t.advance(4), await this.animatePageOut(t), t.animation.native && document.startViewTransition ? await document.startViewTransition(async () => await this.renderPage(t, await a)).finished : await this.renderPage(t, await a), await this.animatePageIn(t) }), t.done)) return; await this.hooks.call("visit:end", t, void 0, () => this.classes.clear()), t.state = 7, this.navigating = !1, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0) } catch (a) { if (!a || a != null && a.aborted) return void (t.state = 8); t.state = 9, console.error(a), this.options.skipPopStateHandling = () => (window.location.assign(t.to.url + t.to.hash), !0), window.history.back() } finally { delete t.to.document } } const Kd = async function (t) { await this.hooks.call("animation:out:start", t, void 0, () => { this.classes.add("is-changing", "is-animating", "is-leaving") }), await this.hooks.call("animation:out:await", t, { skip: !1 }, (e, { skip: n }) => { if (!n) return this.awaitAnimations({ selector: e.animation.selector }) }), await this.hooks.call("animation:out:end", t, void 0) }, Gd = function (t) { var e; const n = t.to.document; if (!n) return !1; const r = ((e = n.querySelector("title")) == null ? void 0 : e.innerText) || ""; document.title = r; const o = ls('[data-swup-persist]:not([data-swup-persist=""])'), s = t.containers.map(i => { const a = document.querySelector(i), c = n.querySelector(i); return a && c ? (a.replaceWith(c.cloneNode(!0)), !0) : (a || console.warn(`[swup] Container missing in current document: ${i}`), c || console.warn(`[swup] Container missing in incoming document: ${i}`), !1) }).filter(Boolean); return o.forEach(i => { const a = i.getAttribute("data-swup-persist"), c = bo(`[data-swup-persist="${a}"]`); c && c !== i && c.replaceWith(i) }), s.length === t.containers.length }, Zd = function (t) { const e = { behavior: "auto" }, { target: n, reset: r } = t.scroll, o = n ?? t.to.hash; let s = !1; return o && (s = this.hooks.callSync("scroll:anchor", t, { hash: o, options: e }, (i, { hash: a, options: c }) => { const l = this.getAnchorElement(a); return l && l.scrollIntoView(c), !!l })), r && !s && (s = this.hooks.callSync("scroll:top", t, { options: e }, (i, { options: a }) => (window.scrollTo(gt({ top: 0, left: 0 }, a)), !0))), s }, Xd = async function (t) { if (t.done) return; const e = this.hooks.call("animation:in:await", t, { skip: !1 }, (n, { skip: r }) => { if (!r) return this.awaitAnimations({ selector: n.animation.selector }) }); await sc(), await this.hooks.call("animation:in:start", t, void 0, () => { this.classes.remove("is-animating") }), await e, await this.hooks.call("animation:in:end", t, void 0) }, Yd = async function (t, e) { if (t.done) return; t.advance(6); const { url: n } = e; this.isSameResolvedUrl(ge(), n) || (Je(n), this.location = vt.fromUrl(n), t.to.url = this.location.url, t.to.hash = this.location.hash), await this.hooks.call("content:replace", t, { page: e }, (r, { }) => { if (this.classes.remove("is-leaving"), r.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(r)) throw new Error("[swup] Container mismatch, aborting"); r.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), r.animation.name && this.classes.add(`to-${oc(r.animation.name)}`)) }), await this.hooks.call("content:scroll", t, void 0, () => this.scrollToContent(t)), await this.hooks.call("page:view", t, { url: this.location.url, title: document.title }) }, Jd = function (t) { var e; if (e = t, !!e?.isSwupPlugin) { if (t.swup = this, !t._checkRequirements || t._checkRequirements()) return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins } else console.error("Not a swup plugin instance", t) }; function Qd(t) { const e = this.findPlugin(t); if (e) return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter(n => n !== e), this.plugins; console.error("No such plugin", e) } function th(t) { return this.plugins.find(e => e === t || e.name === t || e.name === `Swup${String(t)}`) } function eh(t) { if (typeof this.options.resolveUrl != "function") return console.warn("[swup] options.resolveUrl expects a callback function."), t; const e = this.options.resolveUrl(t); return e && typeof e == "string" ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t) } function nh(t, e) { return this.resolveUrl(t) === this.resolveUrl(e) } const rh = { animateHistoryBrowsing: !1, animationSelector: '[class*="transition-"]', animationScope: "html", cache: !0, containers: ["#swup"], hooks: {}, ignoreVisit: (t, { el: e } = {}) => !(e == null || !e.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: !1, plugins: [], resolveUrl: t => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: t => { var e; return ((e = t.state) == null ? void 0 : e.source) !== "swup" }, timeout: 0 }; let oh = class { get currentPageUrl() { return this.location.url } constructor(e = {}) { var n, r; this.version = "4.8.2", this.options = void 0, this.defaults = rh, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = vt.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = !1, this.onVisitEnd = void 0, this.use = Jd, this.unuse = Qd, this.findPlugin = th, this.log = () => { }, this.navigate = Ud, this.performNavigation = Wd, this.createVisit = qd, this.delegateEvent = Nd, this.fetchPage = Hd, this.awaitAnimations = Vd, this.renderPage = Yd, this.replaceContent = Gd, this.animatePageIn = Xd, this.animatePageOut = Kd, this.scrollToContent = Zd, this.getAnchorElement = zd, this.getCurrentUrl = ge, this.resolveUrl = eh, this.isSameResolvedUrl = nh, this.options = gt({}, this.defaults, e), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new Dd(this), this.classes = new jd(this), this.hooks = new Fd(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = (n = (r = window.history.state) == null ? void 0 : r.index) != null ? n : 1, this.enable() } async enable() { var e; const { linkSelector: n } = this.options; this.clickDelegate = this.delegateEvent(n, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach(r => this.use(r)); for (const [r, o] of Object.entries(this.options.hooks)) { const [s, i] = this.hooks.parseName(r); this.hooks.on(s, o, i) } ((e = window.history.state) == null ? void 0 : e.source) !== "swup" && Je(null, { index: this.currentHistoryIndex }), await sc(), await this.hooks.call("enable", void 0, void 0, () => { const r = document.documentElement; r.classList.add("swup-enabled"), r.classList.toggle("swup-native", this.options.native) }) } async destroy() { this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach(e => this.unuse(e)), await this.hooks.call("disable", void 0, void 0, () => { const e = document.documentElement; e.classList.remove("swup-enabled"), e.classList.remove("swup-native") }), this.hooks.clear() } shouldIgnoreVisit(e, { el: n, event: r } = {}) { const { origin: o, url: s, hash: i } = vt.fromUrl(e); return o !== window.location.origin || !(!n || !this.triggerWillOpenNewWindow(n)) || !!this.options.ignoreVisit(s + i, { el: n, event: r }) } handleLinkClick(e) { const n = e.delegateTarget, { href: r, url: o, hash: s } = vt.fromElement(n); if (this.shouldIgnoreVisit(r, { el: n, event: e })) return; if (this.navigating && o === this.visit.to.url) return void e.preventDefault(); const i = this.createVisit({ to: o, hash: s, el: n, event: e }); e.metaKey || e.ctrlKey || e.shiftKey || e.altKey ? this.hooks.callSync("link:newtab", i, { href: r }) : e.button === 0 && this.hooks.callSync("link:click", i, { el: n, event: e }, () => { var a; const c = (a = i.from.url) != null ? a : ""; e.preventDefault(), o && o !== c ? this.isSameResolvedUrl(o, c) || this.performNavigation(i) : s ? this.hooks.callSync("link:anchor", i, { hash: s }, () => { Je(o + s), this.scrollToContent(i) }) : this.hooks.callSync("link:self", i, void 0, () => { this.options.linkToSelf === "navigate" ? this.performNavigation(i) : (Je(o), this.scrollToContent(i)) }) }) } handlePopState(e) { var n, r, o, s; const i = (n = (r = e.state) == null ? void 0 : r.url) != null ? n : window.location.href; if (this.options.skipPopStateHandling(e) || this.isSameResolvedUrl(ge(), this.location.url)) return; const { url: a, hash: c } = vt.fromUrl(i), l = this.createVisit({ to: a, hash: c, event: e }); l.history.popstate = !0; const u = (o = (s = e.state) == null ? void 0 : s.index) != null ? o : 0; u && u !== this.currentHistoryIndex && (l.history.direction = u - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = u), l.animation.animate = !1, l.scroll.reset = !1, l.scroll.target = !1, this.options.animateHistoryBrowsing && (l.animation.animate = !0, l.scroll.reset = !0), this.hooks.callSync("history:popstate", l, { event: e }, () => { this.performNavigation(l) }) } triggerWillOpenNewWindow(e) { return !!e.matches('[download], [target="_blank"]') } }; function Qe() { return Qe = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Qe.apply(this, arguments) } const ti = t => String(t).split(".").map(e => String(parseInt(e || "0", 10))).concat(["0", "0"]).slice(0, 3).join("."); let Er = class { constructor() { this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [] } mount() { } unmount() { this.handlersToUnregister.forEach(e => e()), this.handlersToUnregister = [] } _beforeMount() { if (!this.name) throw new Error("You must define a name of plugin when creating a class.") } _afterUnmount() { } _checkRequirements() { return typeof this.requires != "object" || Object.entries(this.requires).forEach(([e, n]) => { if (!(function (r, o, s) { const i = (function (a, c) { var l; if (a === "swup") return (l = c.version) != null ? l : ""; { var u; const d = c.findPlugin(a); return (u = d?.version) != null ? u : "" } })(r, s); return !!i && ((a, c) => c.every(l => { const [, u, d] = l.match(/^([\D]+)?(.*)$/) || []; var f, m; return ((h, _) => { const p = { "": g => g === 0, ">": g => g > 0, ">=": g => g >= 0, "<": g => g < 0, "<=": g => g <= 0 }; return (p[_] || p[""])(h) })((m = d, f = ti(f = a), m = ti(m), f.localeCompare(m, void 0, { numeric: !0 })), u || ">=") }))(i, o) })(e, n = Array.isArray(n) ? n : [n], this.swup)) { const r = `${e} ${n.join(", ")}`; throw new Error(`Plugin version mismatch: ${this.name} requires ${r}`) } }), !0 } on(e, n, r = {}) { var o; n = !(o = n).name.startsWith("bound ") || o.hasOwnProperty("prototype") ? n.bind(this) : n; const s = this.swup.hooks.on(e, n, r); return this.handlersToUnregister.push(s), s } once(e, n, r = {}) { return this.on(e, n, Qe({}, r, { once: !0 })) } before(e, n, r = {}) { return this.on(e, n, Qe({}, r, { before: !0 })) } replace(e, n, r = {}) { return this.on(e, n, Qe({}, r, { replace: !0 })) } off(e, n) { return this.swup.hooks.off(e, n) } }; function er() { return er = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, er.apply(null, arguments) } function ei(t) { return t.localName !== "title" && !t.matches("[data-swup-theme]") } function ni(t, e) { return t.outerHTML === e.outerHTML } function ri(t, e = []) { const n = Array.from(t.attributes); return e.length ? n.filter(({ name: r }) => e.some(o => o instanceof RegExp ? o.test(r) : r === o)) : n } function sh(t) { return t.matches("link[rel=stylesheet][href]") } let ih = class extends Er { constructor(e = {}) { var n; super(), n = this, this.name = "SwupHeadPlugin", this.requires = { swup: ">=4.6" }, this.defaults = { persistTags: !1, persistAssets: !1, awaitAssets: !1, attributes: ["lang", "dir"], timeout: 3e3 }, this.options = void 0, this.updateHead = async function (r, { page: { } }) { const { awaitAssets: o, attributes: s, timeout: i } = n.options, a = r.to.document, { removed: c, added: l } = (function (u, d, { shouldPersist: f = () => !1 } = {}) { const m = Array.from(u.children), h = Array.from(d.children), _ = (p = m, h.reduce((b, w, k) => (p.some(P => ni(w, P)) || b.push({ el: w, index: k }), b), [])); var p; const g = (function (b, w) { return b.reduce((k, P) => (w.some(M => ni(P, M)) || k.push({ el: P }), k), []) })(m, h); g.reverse().filter(({ el: b }) => ei(b)).filter(({ el: b }) => !f(b)).forEach(({ el: b }) => u.removeChild(b)); const v = _.filter(({ el: b }) => ei(b)).map(b => { let w = b.el.cloneNode(!0); return u.insertBefore(w, u.children[(b.index || 0) + 1] || null), er({}, b, { el: w }) }); return { removed: g.map(({ el: b }) => b), added: v.map(({ el: b }) => b) } })(document.head, a.head, { shouldPersist: u => n.isPersistentTag(u) }); if (n.swup.log(`Removed ${c.length} / added ${l.length} tags in head`), s != null && s.length && (function (u, d, f = []) { const m = new Set; for (const { name: h, value: _ } of ri(d, f)) u.setAttribute(h, _), m.add(h); for (const { name: h } of ri(u, f)) m.has(h) || u.removeAttribute(h) })(document.documentElement, a.documentElement, s), o) { const u = (function (d, f = 0) { return d.filter(sh).map(m => (function (h, _ = 0) { let p; const g = v => { h.sheet ? v() : p = setTimeout(() => g(v), 10) }; return new Promise(v => { g(() => v(h)), _ > 0 && setTimeout(() => { p && clearTimeout(p), v(h) }, _) }) })(m, f)) })(l, i); u.length && (n.swup.log(`Waiting for ${u.length} assets to load`), await Promise.all(u)) } }, this.options = er({}, this.defaults, e), this.options.persistAssets && !this.options.persistTags && (this.options.persistTags = "link[rel=stylesheet], script[src], style") } mount() { this.before("content:replace", this.updateHead) } isPersistentTag(e) { const { persistTags: n } = this.options; return typeof n == "function" ? n(e) : typeof n == "string" && n.length > 0 ? e.matches(n) : !!n } }; function nr() { return nr = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, nr.apply(null, arguments) } function oi() { return window.matchMedia("(hover: hover)").matches } function Mn(t) { return !!t && (t instanceof HTMLAnchorElement || t instanceof SVGAElement) } const si = window.requestIdleCallback || (t => setTimeout(t, 1)), ah = ["preloadVisibleLinks"]; let ch = class extends Er { constructor(e = {}) { var n; super(), n = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: !0, preloadHoveredLinks: !0, preloadVisibleLinks: { enabled: !1, threshold: .2, delay: 500, containers: ["body"], ignore: () => !1 } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = new Map, this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (s, i, a) => { const { url: c } = s.to; return c && this.preloadPromises.has(c) ? this.preloadPromises.get(c) : a(s, i) }, this.onMouseEnter = async function (s) { if (s.target !== s.delegateTarget || !oi()) return; const i = s.delegateTarget; if (!Mn(i)) return; const { url: a, hash: c } = vt.fromElement(i), l = n.swup.createVisit({ to: a, hash: c, el: i, event: s }); n.swup.hooks.callSync("link:hover", l, { el: i, event: s }), n.preload(i, { priority: !0 }) }, this.onTouchStart = s => { if (oi()) return; const i = s.delegateTarget; Mn(i) && this.preload(i, { priority: !0 }) }, this.onFocus = s => { const i = s.delegateTarget; Mn(i) && this.preload(i, { priority: !0 }) }; const { preloadVisibleLinks: r } = e, o = (function (s, i) { if (s == null) return {}; var a = {}; for (var c in s) if ({}.hasOwnProperty.call(s, c)) { if (i.includes(c)) continue; a[c] = s[c] } return a })(e, ah); this.options = nr({}, this.defaults, o), typeof r == "object" ? this.options.preloadVisibleLinks = nr({}, this.options.preloadVisibleLinks, { enabled: !0 }, r) : this.options.preloadVisibleLinks.enabled = !!r, this.preload = this.preload.bind(this), this.queue = (function (s = 1) { const i = [], a = []; let c = 0, l = 0; function u() { l < s && c > 0 && ((a.shift() || i.shift() || (() => { }))(), c--, l++) } return { add: function (d, f = !1) { if (d.__queued) { if (!f) return; { const m = i.indexOf(d); if (m >= 0) { const h = i.splice(m, 1); c -= h.length } } } d.__queued = !0, (f ? a : i).push(d), c++, c <= 1 && u() }, next: function () { l--, u() } } })(this.options.throttle) } mount() { const e = this.swup; e.options.cache ? (e.hooks.create("page:preload"), e.hooks.create("link:hover"), e.preload = this.preload, e.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(ge())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading") } unmount() { var e, n, r; this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), (e = this.mouseEnterDelegate) == null || e.destroy(), (n = this.touchStartDelegate) == null || n.destroy(), (r = this.focusDelegate) == null || r.destroy(), this.stopPreloadingVisibleLinks() } async preload(e, n = {}) { var r; let o, s; const i = (r = n.priority) != null && r; if (Array.isArray(e)) return Promise.all(e.map(c => this.preload(c))); if (Mn(e)) s = e, { href: o } = vt.fromElement(e); else { if (typeof e != "string") return; o = e } if (!o) return; if (this.swup.cache.has(o)) return this.swup.cache.get(o); if (this.preloadPromises.has(o)) return this.preloadPromises.get(o); if (!this.shouldPreload(o, { el: s })) return; const a = new Promise(c => { this.queue.add(() => { this.performPreload(o).catch(() => { }).then(l => c(l)).finally(() => { this.queue.next(), this.preloadPromises.delete(o) }) }, i) }); return this.preloadPromises.set(o, a), a } preloadLinks() { si(() => { Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach(e => this.preload(e)) }) } preloadLinksOnAttention() { const { swup: e } = this, { linkSelector: n } = e.options, r = { passive: !0, capture: !0 }; this.mouseEnterDelegate = e.delegateEvent(n, "mouseenter", this.onMouseEnter, r), this.touchStartDelegate = e.delegateEvent(n, "touchstart", this.onTouchStart, r), this.focusDelegate = e.delegateEvent(n, "focus", this.onFocus, r) } preloadVisibleLinks() { if (this.preloadObserver) return void this.preloadObserver.update(); const { threshold: e, delay: n, containers: r } = this.options.preloadVisibleLinks; this.preloadObserver = (function ({ threshold: o, delay: s, containers: i, callback: a, filter: c }) { const l = new Map, u = new IntersectionObserver(h => { h.forEach(_ => { _.isIntersecting ? d(_.target) : f(_.target) }) }, { threshold: o }), d = h => { var _; const { href: p } = vt.fromElement(h), g = (_ = l.get(p)) != null ? _ : new Set; l.set(p, g), g.add(h), setTimeout(() => { const v = l.get(p); v != null && v.size && (a(h), u.unobserve(h), v.delete(h)) }, s) }, f = h => { var _; const { href: p } = vt.fromElement(h); (_ = l.get(p)) == null || _.delete(h) }, m = () => { si(() => { const h = i.map(_ => `${_} a[*|href]`).join(", "); Array.from(document.querySelectorAll(h)).filter(_ => c(_)).forEach(_ => u.observe(_)) }) }; return { start: () => m(), stop: () => u.disconnect(), update: () => (l.clear(), m()) } })({ threshold: e, delay: n, containers: r, callback: o => this.preload(o), filter: o => { if (this.options.preloadVisibleLinks.ignore(o) || !o.matches(this.swup.options.linkSelector)) return !1; const { href: s } = vt.fromElement(o); return this.shouldPreload(s, { el: o }) } }), this.preloadObserver.start() } stopPreloadingVisibleLinks() { this.preloadObserver && this.preloadObserver.stop() } shouldPreload(e, { el: n } = {}) { const { url: r, href: o } = vt.fromUrl(e); return !(!(function () { if (navigator.connection) { var s; if (navigator.connection.saveData || (s = navigator.connection.effectiveType) != null && s.endsWith("2g")) return !1 } return !0 })() || this.swup.cache.has(r) || this.preloadPromises.has(r) || this.swup.shouldIgnoreVisit(o, { el: n }) || n && this.swup.resolveUrl(r) === this.swup.resolveUrl(ge())) } async performPreload(e) { var n = this; const { url: r } = vt.fromUrl(e), o = this.swup.createVisit({ to: r }); return await this.swup.hooks.call("page:preload", o, { url: r }, async function (i, a) { return a.page = await n.swup.fetchPage(e, { visit: i }), a.page }) } }; const ii = t => typeof t == "object" && t != null && t.nodeType === 1, ai = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip", Rn = (t, e) => { if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) { const n = getComputedStyle(t, null); return ai(n.overflowY, e) || ai(n.overflowX, e) || (r => { const o = (s => { if (!s.ownerDocument || !s.ownerDocument.defaultView) return null; try { return s.ownerDocument.defaultView.frameElement } catch { return null } })(r); return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth) })(t) } return !1 }, Nn = (t, e, n, r, o, s, i, a) => s < t && i > e || s > t && i < e ? 0 : s <= t && a <= n || i >= e && a >= n ? s - t - r : i > e && a < n || s < t && a > n ? i - e + o : 0, lh = t => { const e = t.parentElement; return e ?? (t.getRootNode().host || null) }, uh = (t, e) => { var n, r, o, s; if (typeof document > "u") return []; const { scrollMode: i, block: a, inline: c, boundary: l, skipOverflowHiddenElements: u } = e, d = typeof l == "function" ? l : U => U !== l; if (!ii(t)) throw new TypeError("Invalid target"); const f = document.scrollingElement || document.documentElement, m = []; let h = t; for (; ii(h) && d(h);) { if (h = lh(h), h === f) { m.push(h); break } h != null && h === document.body && Rn(h) && !Rn(document.documentElement) || h != null && Rn(h, u) && m.push(h) } const _ = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, p = (s = (o = window.visualViewport) == null ? void 0 : o.height) != null ? s : innerHeight, { scrollX: g, scrollY: v } = window, { height: b, width: w, top: k, right: P, bottom: M, left: j } = t.getBoundingClientRect(), { top: O, right: E, bottom: C, left: A } = (U => { const I = window.getComputedStyle(U); return { top: parseFloat(I.scrollMarginTop) || 0, right: parseFloat(I.scrollMarginRight) || 0, bottom: parseFloat(I.scrollMarginBottom) || 0, left: parseFloat(I.scrollMarginLeft) || 0 } })(t); let N = a === "start" || a === "nearest" ? k - O : a === "end" ? M + C : k + b / 2 - O + C, q = c === "center" ? j + w / 2 - A + E : c === "end" ? P + E : j - A; const K = []; for (let U = 0; U < m.length; U++) { const I = m[U], { height: Z, width: W, top: Q, right: R, bottom: B, left: y } = I.getBoundingClientRect(); if (i === "if-needed" && k >= 0 && j >= 0 && M <= p && P <= _ && (I === f && !Rn(I) || k >= Q && M <= B && j >= y && P <= R)) return K; const $ = getComputedStyle(I), x = parseInt($.borderLeftWidth, 10), S = parseInt($.borderTopWidth, 10), T = parseInt($.borderRightWidth, 10), L = parseInt($.borderBottomWidth, 10); let H = 0, z = 0; const Y = "offsetWidth" in I ? I.offsetWidth - I.clientWidth - x - T : 0, G = "offsetHeight" in I ? I.offsetHeight - I.clientHeight - S - L : 0, tt = "offsetWidth" in I ? I.offsetWidth === 0 ? 0 : W / I.offsetWidth : 0, V = "offsetHeight" in I ? I.offsetHeight === 0 ? 0 : Z / I.offsetHeight : 0; if (f === I) H = a === "start" ? N : a === "end" ? N - p : a === "nearest" ? Nn(v, v + p, p, S, L, v + N, v + N + b, b) : N - p / 2, z = c === "start" ? q : c === "center" ? q - _ / 2 : c === "end" ? q - _ : Nn(g, g + _, _, x, T, g + q, g + q + w, w), H = Math.max(0, H + v), z = Math.max(0, z + g); else { H = a === "start" ? N - Q - S : a === "end" ? N - B + L + G : a === "nearest" ? Nn(Q, B, Z, S, L + G, N, N + b, b) : N - (Q + Z / 2) + G / 2, z = c === "start" ? q - y - x : c === "center" ? q - (y + W / 2) + Y / 2 : c === "end" ? q - R + T + Y : Nn(y, R, W, x, T + Y, q, q + w, w); const { scrollLeft: ht, scrollTop: mt } = I; H = V === 0 ? 0 : Math.max(0, Math.min(mt + H / V, I.scrollHeight - Z / V + G)), z = tt === 0 ? 0 : Math.max(0, Math.min(ht + z / tt, I.scrollWidth - W / tt + Y)), N += mt - H, q += ht - z } K.push({ el: I, top: H, left: z }) } return K }; function xo() { return xo = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, xo.apply(null, arguments) } const ci = (t, e = document) => Array.from(e.querySelectorAll(t)); let dh = class extends Er { constructor(e = {}) { super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4.2.0" }, this.defaults = { doScrollingRightAway: !1, animateScroll: { betweenPages: !0, samePageWithHash: !0, samePage: !0 }, getAnchorElement: void 0, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: () => !0, markScrollTarget: !1, scrollFunction: void 0 }, this.options = void 0, this.cachedScrollPositions = {}, this.previousScrollRestoration = void 0, this.currentCacheKey = void 0, this.getAnchorElement = (n = "") => typeof this.options.getAnchorElement == "function" ? this.options.getAnchorElement(n) : this.swup.getAnchorElement(n), this.getOffset = (n, r, o) => { let s; return s = typeof this.options.offset == "function" ? this.options.offset(n, r, o) : this.options.offset, typeof s == "object" && typeof s.top == "number" && typeof s.left == "number" ? s : { top: parseInt(String(s ?? ""), 10) || 0, left: 0 } }, this.onBeforeLinkToSelf = n => { n.scroll.animate = this.shouldAnimate("samePage") }, this.handleScrollToTop = n => (this.scrollTo({ top: 0, left: 0 }, n.scroll.animate), !0), this.onBeforeLinkToAnchor = n => { n.scroll.animate = this.shouldAnimate("samePageWithHash") }, this.handleScrollToAnchor = (n, { hash: r }) => this.maybeScrollToAnchor(r, n.scroll.animate), this.onBeforeVisitStart = n => { n.scroll.scrolledToContent = !1, n.scroll.animate = this.shouldAnimate("betweenPages") }, this.onVisitStart = n => { var r; this.cacheScrollPositions(n.from.url), this.maybeResetScrollPositions(n); const o = (r = n.scroll.target) != null ? r : n.to.hash; n.scroll.animate && this.options.doScrollingRightAway && !o && this.doScrollingBetweenPages(n) }, this.handleScrollToContent = n => { n.scroll.scrolledToContent || this.doScrollingBetweenPages(n), this.restoreScrollContainers(n.to.url) }, this.doScrollingBetweenPages = n => { var r; if (n.history.popstate && !n.animation.animate) return; const o = (r = n.scroll.target) != null ? r : n.to.hash; if (o && this.maybeScrollToAnchor(o, n.scroll.animate) || !n.scroll.reset) return; const s = this.getCachedScrollPositions(n.to.url), { top: i = 0, left: a = 0 } = s?.window || { top: 0, left: 0 }; requestAnimationFrame(() => this.scrollTo({ top: i, left: a }, n.scroll.animate)), n.scroll.scrolledToContent = !0 }, this.maybeResetScrollPositions = n => { const { popstate: r } = n.history, { url: o } = n.to, { el: s } = n.trigger; r || s && !this.options.shouldResetScrollPosition(s) || this.resetScrollPositions(o) }, this.options = xo({}, this.defaults, e) } mount() { const e = this.swup; e.hooks.create("scroll:start"), e.hooks.create("scroll:end"), e.scrollTo = this.scrollTo.bind(this), this.previousScrollRestoration = window.history.scrollRestoration, e.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.updateScrollTarget = this.updateScrollTarget.bind(this), this.options.markScrollTarget && (window.addEventListener("popstate", this.updateScrollTarget), window.addEventListener("hashchange", this.updateScrollTarget), this.on("page:view", this.updateScrollTarget), this.on("link:anchor", this.updateScrollTarget), this.on("link:self", this.updateScrollTarget), this.updateScrollTarget()), this.before("visit:start", this.onBeforeVisitStart, { priority: -1 }), this.on("visit:start", this.onVisitStart, { priority: 1 }), this.replace("content:scroll", this.handleScrollToContent), this.before("link:self", this.onBeforeLinkToSelf, { priority: -1 }), this.replace("scroll:top", this.handleScrollToTop), this.before("link:anchor", this.onBeforeLinkToAnchor, { priority: -1 }), this.replace("scroll:anchor", this.handleScrollToAnchor) } unmount() { super.unmount(), this.previousScrollRestoration && (window.history.scrollRestoration = this.previousScrollRestoration), window.removeEventListener("popstate", this.updateScrollTarget), window.removeEventListener("hashchange", this.updateScrollTarget), this.cachedScrollPositions = {}, delete this.swup.scrollTo } shouldAnimate(e) { return typeof this.options.animateScroll == "boolean" ? this.options.animateScroll : this.options.animateScroll[e] } maybeScrollToAnchor(e, n = !1) { if (!e) return !1; const r = this.getAnchorElement(e); return r ? r instanceof Element ? (this.scrollElementIntoView(r, n), !0) : (console.warn(`Anchor target ${e} is not a DOM node`), !1) : (console.warn(`Anchor target ${e} not found`), !1) } cacheScrollPositions(e) { const n = this.swup.resolveUrl(e), r = ci(this.options.scrollContainers).map(s => ({ top: s.scrollTop, left: s.scrollLeft })), o = { window: { top: window.scrollY, left: window.scrollX }, containers: r }; this.cachedScrollPositions[n] = o } resetScrollPositions(e) { const n = this.swup.resolveUrl(e); delete this.cachedScrollPositions[n] } getCachedScrollPositions(e) { const n = this.swup.resolveUrl(e); return this.cachedScrollPositions[n] } restoreScrollContainers(e) { const n = this.getCachedScrollPositions(e); n && n.containers.length !== 0 && ci(this.options.scrollContainers).forEach((r, o) => { const s = n.containers[o]; s != null && (r.scrollTop = s.top, r.scrollLeft = s.left) }) } updateScrollTarget() { var e; const { hash: n } = window.location, r = document.querySelector("[data-swup-scroll-target]"); let o = this.getAnchorElement(n); o instanceof HTMLBodyElement && (o = null), r !== o && (r?.removeAttribute("data-swup-scroll-target"), (e = o) == null || e.setAttribute("data-swup-scroll-target", "")) } getRootScrollContainer() { return document.scrollingElement instanceof HTMLElement ? document.scrollingElement : document.documentElement } scrollTo(e, n = !0, r) { var o; const s = this.swup.createVisit({ to: this.swup.location.url }), { top: i = 0, left: a = 0 } = typeof e == "number" ? { top: e } : e; r != null || (r = this.getRootScrollContainer()), ((o = this.options.scrollFunction) != null ? o : this.applyScroll)(r, i, a, n, () => this.swup.hooks.callSync("scroll:start", s, void 0), () => this.swup.hooks.callSync("scroll:end", s, void 0)) } applyScroll(e, n, r, o, s, i) { const a = e instanceof HTMLHtmlElement || e instanceof HTMLBodyElement ? window : e; s(), a.addEventListener("scrollend", i, { once: !0 }), a.addEventListener("wheel", () => { e.scrollTo({ top: e.scrollTop, left: e.scrollLeft, behavior: "instant" }) }, { once: !0 }), e.scrollTo({ top: n, left: r, behavior: o ? "smooth" : "instant" }) } scrollElementIntoView(e, n = !1) { uh(e, { scrollMode: "always", block: "start", inline: "start" }).forEach(({ top: r, left: o, el: s }) => { const { top: i = 0, left: a = 0 } = this.getOffset(e, s, { top: r, left: o }); this.scrollTo({ top: r - i, left: o - a }, n, s) }) } }; function So() { return So = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, So.apply(this, arguments) } let hh = class extends Er { constructor(e = {}) { super(), this.name = "SwupScriptsPlugin", this.requires = { swup: ">=4" }, this.defaults = { head: !0, body: !0, optin: !1 }, this.options = void 0, this.options = So({}, this.defaults, e) } mount() { this.on("content:replace", this.runScripts) } runScripts() { const { head: e, body: n, optin: r } = this.options, o = this.getScope({ head: e, body: n }); if (!o) return; const s = Array.from(o.querySelectorAll(r ? "script[data-swup-reload-script]" : "script:not([data-swup-ignore-script])")); s.forEach(i => this.runScript(i)), this.swup.log(`Executed ${s.length} scripts.`) } runScript(e) { const n = document.createElement("script"); for (const { name: r, value: o } of e.attributes) n.setAttribute(r, o); return n.textContent = e.textContent, e.replaceWith(n), n } getScope({ head: e, body: n }) { return e && n ? document : e ? document.head : n ? document.body : null } }; var $r, et, cc, fh, ce, li, lc, uc, dc, us, Eo, $o, ph, nn = {}, hc = [], mh = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Cr = Array.isArray; function Wt(t, e) { for (var n in e) t[n] = e[n]; return t } function ds(t) { t && t.parentNode && t.parentNode.removeChild(t) } function gh(t, e, n) { var r, o, s, i = {}; for (s in e) s == "key" ? r = e[s] : s == "ref" ? o = e[s] : i[s] = e[s]; if (arguments.length > 2 && (i.children = arguments.length > 3 ? $r.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null) for (s in t.defaultProps) i[s] === void 0 && (i[s] = t.defaultProps[s]); return Vn(t, i, r, o, null) } function Vn(t, e, n, r, o) { var s = { type: t, props: e, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: o ?? ++cc, __i: -1, __u: 0 }; return o == null && et.vnode != null && et.vnode(s), s } function Re(t) { return t.children } function Un(t, e) { this.props = t, this.context = e } function Ae(t, e) { if (e == null) return t.__ ? Ae(t.__, t.__i + 1) : null; for (var n; e < t.__k.length; e++)if ((n = t.__k[e]) != null && n.__e != null) return n.__e; return typeof t.type == "function" ? Ae(t) : null } function fc(t) { var e, n; if ((t = t.__) != null && t.__c != null) { for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)if ((n = t.__k[e]) != null && n.__e != null) { t.__e = t.__c.base = n.__e; break } return fc(t) } } function ui(t) { (!t.__d && (t.__d = !0) && ce.push(t) && !rr.__r++ || li != et.debounceRendering) && ((li = et.debounceRendering) || lc)(rr) } function rr() { for (var t, e, n, r, o, s, i, a = 1; ce.length;)ce.length > a && ce.sort(uc), t = ce.shift(), a = ce.length, t.__d && (n = void 0, o = (r = (e = t).__v).__e, s = [], i = [], e.__P && ((n = Wt({}, r)).__v = r.__v + 1, et.vnode && et.vnode(n), hs(e.__P, n, r, e.__n, e.__P.namespaceURI, 32 & r.__u ? [o] : null, s, o ?? Ae(r), !!(32 & r.__u), i), n.__v = r.__v, n.__.__k[n.__i] = n, gc(s, n, i), n.__e != o && fc(n))); rr.__r = 0 } function pc(t, e, n, r, o, s, i, a, c, l, u) { var d, f, m, h, _, p, g, v = r && r.__k || hc, b = e.length; for (c = _h(n, e, v, c, b), d = 0; d < b; d++)(m = n.__k[d]) != null && (f = m.__i == -1 ? nn : v[m.__i] || nn, m.__i = d, p = hs(t, m, f, o, s, i, a, c, l, u), h = m.__e, m.ref && f.ref != m.ref && (f.ref && fs(f.ref, null, m), u.push(m.ref, m.__c || h, m)), _ == null && h != null && (_ = h), (g = !!(4 & m.__u)) || f.__k === m.__k ? c = mc(m, c, t, g) : typeof m.type == "function" && p !== void 0 ? c = p : h && (c = h.nextSibling), m.__u &= -7); return n.__e = _, c } function _h(t, e, n, r, o) { var s, i, a, c, l, u = n.length, d = u, f = 0; for (t.__k = new Array(o), s = 0; s < o; s++)(i = e[s]) != null && typeof i != "boolean" && typeof i != "function" ? (c = s + f, (i = t.__k[s] = typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? Vn(null, i, null, null, null) : Cr(i) ? Vn(Re, { children: i }, null, null, null) : i.constructor == null && i.__b > 0 ? Vn(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i).__ = t, i.__b = t.__b + 1, a = null, (l = i.__i = vh(i, n, c, d)) != -1 && (d--, (a = n[l]) && (a.__u |= 2)), a == null || a.__v == null ? (l == -1 && (o > u ? f-- : o < u && f++), typeof i.type != "function" && (i.__u |= 4)) : l != c && (l == c - 1 ? f-- : l == c + 1 ? f++ : (l > c ? f-- : f++, i.__u |= 4))) : t.__k[s] = null; if (d) for (s = 0; s < u; s++)(a = n[s]) != null && (2 & a.__u) == 0 && (a.__e == r && (r = Ae(a)), vc(a, a)); return r } function mc(t, e, n, r) { var o, s; if (typeof t.type == "function") { for (o = t.__k, s = 0; o && s < o.length; s++)o[s] && (o[s].__ = t, e = mc(o[s], e, n, r)); return e } t.__e != e && (r && (e && t.type && !e.parentNode && (e = Ae(t)), n.insertBefore(t.__e, e || null)), e = t.__e); do e = e && e.nextSibling; while (e != null && e.nodeType == 8); return e } function vh(t, e, n, r) { var o, s, i, a = t.key, c = t.type, l = e[n], u = l != null && (2 & l.__u) == 0; if (l === null && t.key == null || u && a == l.key && c == l.type) return n; if (r > (u ? 1 : 0)) { for (o = n - 1, s = n + 1; o >= 0 || s < e.length;)if ((l = e[i = o >= 0 ? o-- : s++]) != null && (2 & l.__u) == 0 && a == l.key && c == l.type) return i } return -1 } function di(t, e, n) { e[0] == "-" ? t.setProperty(e, n ?? "") : t[e] = n == null ? "" : typeof n != "number" || mh.test(e) ? n : n + "px" } function Hn(t, e, n, r, o) { var s, i; t: if (e == "style") if (typeof n == "string") t.style.cssText = n; else { if (typeof r == "string" && (t.style.cssText = r = ""), r) for (e in r) n && e in n || di(t.style, e, ""); if (n) for (e in n) r && n[e] == r[e] || di(t.style, e, n[e]) } else if (e[0] == "o" && e[1] == "n") s = e != (e = e.replace(dc, "$1")), i = e.toLowerCase(), e = i in t || e == "onFocusOut" || e == "onFocusIn" ? i.slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = n, n ? r ? n.u = r.u : (n.u = us, t.addEventListener(e, s ? $o : Eo, s)) : t.removeEventListener(e, s ? $o : Eo, s); else { if (o == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try { t[e] = n ?? ""; break t } catch { } typeof n == "function" || (n == null || n === !1 && e[4] != "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && n == 1 ? "" : n)) } } function hi(t) { return function (e) { if (this.l) { var n = this.l[e.type + t]; if (e.t == null) e.t = us++; else if (e.t < n.u) return; return n(et.event ? et.event(e) : e) } } } function hs(t, e, n, r, o, s, i, a, c, l) { var u, d, f, m, h, _, p, g, v, b, w, k, P, M, j, O, E, C = e.type; if (e.constructor != null) return null; 128 & n.__u && (c = !!(32 & n.__u), s = [a = e.__e = n.__e]), (u = et.__b) && u(e); t: if (typeof C == "function") try { if (g = e.props, v = "prototype" in C && C.prototype.render, b = (u = C.contextType) && r[u.__c], w = u ? b ? b.props.value : u.__ : r, n.__c ? p = (d = e.__c = n.__c).__ = d.__E : (v ? e.__c = d = new C(g, w) : (e.__c = d = new Un(g, w), d.constructor = C, d.render = wh), b && b.sub(d), d.props = g, d.state || (d.state = {}), d.context = w, d.__n = r, f = d.__d = !0, d.__h = [], d._sb = []), v && d.__s == null && (d.__s = d.state), v && C.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = Wt({}, d.__s)), Wt(d.__s, C.getDerivedStateFromProps(g, d.__s))), m = d.props, h = d.state, d.__v = e, f) v && C.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), v && d.componentDidMount != null && d.__h.push(d.componentDidMount); else { if (v && C.getDerivedStateFromProps == null && g !== m && d.componentWillReceiveProps != null && d.componentWillReceiveProps(g, w), !d.__e && d.shouldComponentUpdate != null && d.shouldComponentUpdate(g, d.__s, w) === !1 || e.__v == n.__v) { for (e.__v != n.__v && (d.props = g, d.state = d.__s, d.__d = !1), e.__e = n.__e, e.__k = n.__k, e.__k.some(function (A) { A && (A.__ = e) }), k = 0; k < d._sb.length; k++)d.__h.push(d._sb[k]); d._sb = [], d.__h.length && i.push(d); break t } d.componentWillUpdate != null && d.componentWillUpdate(g, d.__s, w), v && d.componentDidUpdate != null && d.__h.push(function () { d.componentDidUpdate(m, h, _) }) } if (d.context = w, d.props = g, d.__P = t, d.__e = !1, P = et.__r, M = 0, v) { for (d.state = d.__s, d.__d = !1, P && P(e), u = d.render(d.props, d.state, d.context), j = 0; j < d._sb.length; j++)d.__h.push(d._sb[j]); d._sb = [] } else do d.__d = !1, P && P(e), u = d.render(d.props, d.state, d.context), d.state = d.__s; while (d.__d && ++M < 25); d.state = d.__s, d.getChildContext != null && (r = Wt(Wt({}, r), d.getChildContext())), v && !f && d.getSnapshotBeforeUpdate != null && (_ = d.getSnapshotBeforeUpdate(m, h)), O = u, u != null && u.type === Re && u.key == null && (O = _c(u.props.children)), a = pc(t, Cr(O) ? O : [O], e, n, r, o, s, i, a, c, l), d.base = e.__e, e.__u &= -161, d.__h.length && i.push(d), p && (d.__E = d.__ = null) } catch (A) { if (e.__v = null, c || s != null) if (A.then) { for (e.__u |= c ? 160 : 128; a && a.nodeType == 8 && a.nextSibling;)a = a.nextSibling; s[s.indexOf(a)] = null, e.__e = a } else { for (E = s.length; E--;)ds(s[E]); Co(e) } else e.__e = n.__e, e.__k = n.__k, A.then || Co(e); et.__e(A, e, n) } else s == null && e.__v == n.__v ? (e.__k = n.__k, e.__e = n.__e) : a = e.__e = yh(n.__e, e, n, r, o, s, i, c, l); return (u = et.diffed) && u(e), 128 & e.__u ? void 0 : a } function Co(t) { t && t.__c && (t.__c.__e = !0), t && t.__k && t.__k.forEach(Co) } function gc(t, e, n) { for (var r = 0; r < n.length; r++)fs(n[r], n[++r], n[++r]); et.__c && et.__c(e, t), t.some(function (o) { try { t = o.__h, o.__h = [], t.some(function (s) { s.call(o) }) } catch (s) { et.__e(s, o.__v) } }) } function _c(t) { return typeof t != "object" || t == null || t.__b && t.__b > 0 ? t : Cr(t) ? t.map(_c) : Wt({}, t) } function yh(t, e, n, r, o, s, i, a, c) { var l, u, d, f, m, h, _, p = n.props, g = e.props, v = e.type; if (v == "svg" ? o = "http://www.w3.org/2000/svg" : v == "math" ? o = "http://www.w3.org/1998/Math/MathML" : o || (o = "http://www.w3.org/1999/xhtml"), s != null) { for (l = 0; l < s.length; l++)if ((m = s[l]) && "setAttribute" in m == !!v && (v ? m.localName == v : m.nodeType == 3)) { t = m, s[l] = null; break } } if (t == null) { if (v == null) return document.createTextNode(g); t = document.createElementNS(o, v, g.is && g), a && (et.__m && et.__m(e, s), a = !1), s = null } if (v == null) p === g || a && t.data == g || (t.data = g); else { if (s = s && $r.call(t.childNodes), p = n.props || nn, !a && s != null) for (p = {}, l = 0; l < t.attributes.length; l++)p[(m = t.attributes[l]).name] = m.value; for (l in p) if (m = p[l], l != "children") { if (l == "dangerouslySetInnerHTML") d = m; else if (!(l in g)) { if (l == "value" && "defaultValue" in g || l == "checked" && "defaultChecked" in g) continue; Hn(t, l, null, m, o) } } for (l in g) m = g[l], l == "children" ? f = m : l == "dangerouslySetInnerHTML" ? u = m : l == "value" ? h = m : l == "checked" ? _ = m : a && typeof m != "function" || p[l] === m || Hn(t, l, m, p[l], o); if (u) a || d && (u.__html == d.__html || u.__html == t.innerHTML) || (t.innerHTML = u.__html), e.__k = []; else if (d && (t.innerHTML = ""), pc(e.type == "template" ? t.content : t, Cr(f) ? f : [f], e, n, r, v == "foreignObject" ? "http://www.w3.org/1999/xhtml" : o, s, i, s ? s[0] : n.__k && Ae(n, 0), a, c), s != null) for (l = s.length; l--;)ds(s[l]); a || (l = "value", v == "progress" && h == null ? t.removeAttribute("value") : h != null && (h !== t[l] || v == "progress" && !h || v == "option" && h != p[l]) && Hn(t, l, h, p[l], o), l = "checked", _ != null && _ != t[l] && Hn(t, l, _, p[l], o)) } return t } function fs(t, e, n) { try { if (typeof t == "function") { var r = typeof t.__u == "function"; r && t.__u(), r && e == null || (t.__u = t(e)) } else t.current = e } catch (o) { et.__e(o, n) } } function vc(t, e, n) { var r, o; if (et.unmount && et.unmount(t), (r = t.ref) && (r.current && r.current != t.__e || fs(r, null, e)), (r = t.__c) != null) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (s) { et.__e(s, e) } r.base = r.__P = null } if (r = t.__k) for (o = 0; o < r.length; o++)r[o] && vc(r[o], e, n || typeof t.type != "function"); n || ds(t.__e), t.__c = t.__ = t.__e = void 0 } function wh(t, e, n) { return this.constructor(t, n) } function Ar(t, e, n) { var r, o, s, i; e == document && (e = document.documentElement), et.__ && et.__(t, e), o = (r = typeof n == "function") ? null : n && n.__k || e.__k, s = [], i = [], hs(e, t = (!r && n || e).__k = gh(Re, null, [t]), o || nn, nn, e.namespaceURI, !r && n ? [n] : o ? null : e.firstChild ? $r.call(e.childNodes) : null, s, !r && n ? n : o ? o.__e : e.firstChild, r, i), gc(s, t, i) } $r = hc.slice, et = { __e: function (t, e, n, r) { for (var o, s, i; e = e.__;)if ((o = e.__c) && !o.__) try { if ((s = o.constructor) && s.getDerivedStateFromError != null && (o.setState(s.getDerivedStateFromError(t)), i = o.__d), o.componentDidCatch != null && (o.componentDidCatch(t, r || {}), i = o.__d), i) return o.__E = o } catch (a) { t = a } throw t } }, cc = 0, fh = function (t) { return t != null && t.constructor == null }, Un.prototype.setState = function (t, e) { var n; n = this.__s != null && this.__s != this.state ? this.__s : this.__s = Wt({}, this.state), typeof t == "function" && (t = t(Wt({}, n), this.props)), t && Wt(n, t), t != null && this.__v && (e && this._sb.push(e), ui(this)) }, Un.prototype.forceUpdate = function (t) { this.__v && (this.__e = !0, t && this.__h.push(t), ui(this)) }, Un.prototype.render = Re, ce = [], lc = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, uc = function (t, e) { return t.__v.__b - e.__v.__b }, rr.__r = 0, dc = /(PointerCapture)$|Capture$/i, us = 0, Eo = hi(!1), $o = hi(!0), ph = 0; var bh = 0, Rp = Array.isArray; function D(t, e, n, r, o, s) { e || (e = {}); var i, a, c = e; if ("ref" in c) for (a in c = {}, e) a == "ref" ? i = e[a] : c[a] = e[a]; var l = { type: t, props: c, key: n, ref: i, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --bh, __i: -1, __u: 0, __source: o, __self: s }; if (typeof t == "function" && (i = t.defaultProps)) for (a in i) c[a] === void 0 && (c[a] = i[a]); return et.vnode && et.vnode(l), l } var rn, dt, Yr, fi, or = 0, yc = [], ft = et, pi = ft.__b, mi = ft.__r, gi = ft.diffed, _i = ft.__c, vi = ft.unmount, yi = ft.__; function ps(t, e) { ft.__h && ft.__h(dt, t, or || e), or = 0; var n = dt.__H || (dt.__H = { __: [], __h: [] }); return t >= n.__.length && n.__.push({}), n.__[t] } function Jt(t) { return or = 1, xh(bc, t) } function xh(t, e, n) { var r = ps(rn++, 2); if (r.t = t, !r.__c && (r.__ = [n ? n(e) : bc(void 0, e), function (a) { var c = r.__N ? r.__N[0] : r.__[0], l = r.t(c, a); c !== l && (r.__N = [l, r.__[1]], r.__c.setState({})) }], r.__c = dt, !dt.__f)) { var o = function (a, c, l) { if (!r.__c.__H) return !0; var u = r.__c.__H.__.filter(function (f) { return !!f.__c }); if (u.every(function (f) { return !f.__N })) return !s || s.call(this, a, c, l); var d = r.__c.props !== a; return u.forEach(function (f) { if (f.__N) { var m = f.__[0]; f.__ = f.__N, f.__N = void 0, m !== f.__[0] && (d = !0) } }), s && s.call(this, a, c, l) || d }; dt.__f = !0; var s = dt.shouldComponentUpdate, i = dt.componentWillUpdate; dt.componentWillUpdate = function (a, c, l) { if (this.__e) { var u = s; s = void 0, o(a, c, l), s = u } i && i.call(this, a, c, l) }, dt.shouldComponentUpdate = o } return r.__N || r.__ } function xe(t, e) { var n = ps(rn++, 3); !ft.__s && wc(n.__H, e) && (n.__ = t, n.u = e, dt.__H.__h.push(n)) } function sr(t) { return or = 5, Sh(function () { return { current: t } }, []) } function Sh(t, e) { var n = ps(rn++, 7); return wc(n.__H, e) && (n.__ = t(), n.__H = e, n.__h = t), n.__ } function Eh() { for (var t; t = yc.shift();)if (t.__P && t.__H) try { t.__H.__h.forEach(Wn), t.__H.__h.forEach(Ao), t.__H.__h = [] } catch (e) { t.__H.__h = [], ft.__e(e, t.__v) } } ft.__b = function (t) { dt = null, pi && pi(t) }, ft.__ = function (t, e) { t && e.__k && e.__k.__m && (t.__m = e.__k.__m), yi && yi(t, e) }, ft.__r = function (t) { mi && mi(t), rn = 0; var e = (dt = t.__c).__H; e && (Yr === dt ? (e.__h = [], dt.__h = [], e.__.forEach(function (n) { n.__N && (n.__ = n.__N), n.u = n.__N = void 0 })) : (e.__h.forEach(Wn), e.__h.forEach(Ao), e.__h = [], rn = 0)), Yr = dt }, ft.diffed = function (t) { gi && gi(t); var e = t.__c; e && e.__H && (e.__H.__h.length && (yc.push(e) !== 1 && fi === ft.requestAnimationFrame || ((fi = ft.requestAnimationFrame) || $h)(Eh)), e.__H.__.forEach(function (n) { n.u && (n.__H = n.u), n.u = void 0 })), Yr = dt = null }, ft.__c = function (t, e) { e.some(function (n) { try { n.__h.forEach(Wn), n.__h = n.__h.filter(function (r) { return !r.__ || Ao(r) }) } catch (r) { e.some(function (o) { o.__h && (o.__h = []) }), e = [], ft.__e(r, n.__v) } }), _i && _i(t, e) }, ft.unmount = function (t) { vi && vi(t); var e, n = t.__c; n && n.__H && (n.__H.__.forEach(function (r) { try { Wn(r) } catch (o) { e = o } }), n.__H = void 0, e && ft.__e(e, n.__v)) }; var wi = typeof requestAnimationFrame == "function"; function $h(t) { var e, n = function () { clearTimeout(r), wi && cancelAnimationFrame(e), setTimeout(t) }, r = setTimeout(n, 35); wi && (e = requestAnimationFrame(n)) } function Wn(t) { var e = dt, n = t.__c; typeof n == "function" && (t.__c = void 0, n()), dt = e } function Ao(t) { var e = dt; t.__c = t.__(), dt = e } function wc(t, e) { return !t || t.length !== e.length || e.some(function (n, r) { return n !== t[r] }) } function bc(t, e) { return typeof e == "function" ? e(t) : e } function Ch() { const [t, e] = Jt(0); return D("div", { class: "mx-3 flex items-center", children: [D("span", { className: "text-2xl font-bold text-pink-400", children: "Preact :" }), D("div", { className: "flex items-center justify-center space-x-3 px-2.5", children: [D("p", { className: "text-2xl font-bold text-pink-400", children: ["Count: ", t] }), D("button", { onClick: () => e(t + 1), className: "btn btn-neutral", children: "Add" })] })] }) } function Ah() { const [t, e] = Jt(), [n, r] = Jt(""), [o, s] = Jt(""), [i, a] = Jt(!1), c = sr(), l = sr(null), u = () => { const p = !i; if (a(p), p) { const g = n || o; g && !t && m(g, !1) } }, d = p => { a(p) }, f = async (p, g) => { if (!p.trim()) { g && d(!1), e(void 0); return } try { const v = await fetch("/apis/api.halo.run/v1alpha1/indices/-/search", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ highlightPostTag: "</mark>", highlightPreTag: "<mark>", keyword: p.trim(), limit: 10 }) }); if (!v.ok) throw new Error(`: ${v.status}`); const b = await v.json(); e(b), b && b.hits && b.hits.length > 0 ? d(!0) : g && d(!1) } catch (v) { console.error(":", v), e(void 0), g && d(!1) } }, m = (p, g) => { c.current && clearTimeout(c.current), c.current = window.setTimeout(() => { f(p, g) }, 300) }, h = (p, g) => { g ? s(p) : r(p), m(p, g) }, _ = (p, g) => { p.key === "Escape" && (a(!1), g ? s("") : r(""), e(void 0)) }; return xe(() => { const p = g => { l.current && !l.current.contains(g.target) && a(!1) }; return i && document.addEventListener("mousedown", p), () => { document.removeEventListener("mousedown", p) } }, [i]), xe(() => () => { c.current && clearTimeout(c.current) }, []), D(Re, { children: [D("div", { id: "search-bar", className: "mr-2 hidden h-11 items-center rounded-lg bg-black/[0.04] transition-all focus-within:bg-black/[0.06] hover:bg-black/[0.06] lg:flex dark:bg-white/5 dark:focus-within:bg-white/10 dark:hover:bg-white/10", children: [D("span", { className: "icon-[tabler--search] pointer-events-none absolute my-auto ml-3 text-[1.25rem] text-black/30 transition dark:text-white/30" }), D("input", { placeholder: "...", value: o, onInput: p => h(p.target.value, !0), onKeyDown: p => _(p, !0), onFocus: () => { t && t.hits.length > 0 ? d(!0) : o && !t && m(o, !0) }, className: "h-full w-40 bg-transparent pl-10 text-sm text-black/50 outline-0 transition-all focus:w-60 active:w-60 dark:text-white/50" })] }), D("button", { onClick: u, "aria-label": "Search Panel", id: "search-switch", className: "btn-plain scale-animation h-11 w-11 rounded-lg active:scale-90 lg:!hidden", children: D("span", { className: "icon-[tabler--search] text-[1.25rem]" }) }), D("div", { ref: l, id: "search-panel", className: `float-panel search-panel absolute top-20 right-4 left-4 overflow-y-auto rounded-2xl p-2 shadow-2xl md:left-[unset] md:w-[30rem] ${i ? "" : "float-panel-closed"}`, children: [D("div", { id: "search-bar-inside", className: "relative flex h-11 items-center rounded-xl bg-black/[0.04] transition-all focus-within:bg-black/[0.06] hover:bg-black/[0.06] lg:hidden dark:bg-white/5 dark:focus-within:bg-white/10 dark:hover:bg-white/10", children: [D("span", { className: "icon-[tabler--search] pointer-events-none absolute my-auto ml-3 text-[1.25rem] text-black/30 transition dark:text-white/30" }), D("input", { placeholder: "...", value: n, onInput: p => h(p.target.value, !1), onKeyDown: p => _(p, !1), className: "absolute inset-0 bg-transparent pl-10 text-sm text-black/50 outline-0 focus:w-60 dark:text-white/50" })] }), t && t.hits.length > 0 && D("div", { className: "mt-2", children: t.hits.map((p, g) => D("a", { href: p.permalink, className: "group block rounded-xl px-3 py-2 text-lg transition hover:bg-[var(--btn-plain-bg-hover)] active:bg-[var(--btn-plain-bg-active)]", onClick: () => a(!1), children: [D("div", { className: "text-90 inline-flex font-bold transition group-hover:text-[var(--primary)]", children: [D("span", { dangerouslySetInnerHTML: { __html: p.title || "" } }), D("span", { className: "icon-[tabler--chevron-right] my-auto translate-x-1 text-[1rem] font-bold text-[var(--primary)] transition" })] }), D("div", { className: "text-50 text-sm transition", dangerouslySetInnerHTML: { __html: p.description || "" } })] }, g)) }), t && t.hits.length === 0 && (n || o) && D("div", { className: "flex flex-col items-center justify-center py-8 text-center", children: [D("span", { className: "icon-[tabler--search-off] mb-2 text-4xl text-black/20 dark:text-white/20" }), D("p", { className: "text-sm text-black/50 dark:text-white/50", children: "" }), D("p", { className: "mt-1 text-xs text-black/30 dark:text-white/30", children: "" })] }), !t && !n && !o && i && D("div", { className: "flex flex-col items-center justify-center py-8 text-center", children: [D("span", { className: "icon-[tabler--search] mb-2 text-4xl text-black/20 dark:text-white/20" }), D("p", { className: "text-sm text-black/50 dark:text-white/50", children: "" }), D("p", { className: "mt-1 text-xs text-black/30 dark:text-white/30", children: "" })] })] })] }) } function xc() { const e = document.getElementById("config-carrier"); return Number.parseInt(e?.dataset.hue || "250") } function Sc() { const t = localStorage.getItem("hue"); return t ? Number.parseInt(t) : xc() } function Ec(t) { localStorage.setItem("hue", String(t)); const e = document.querySelector(":root"); e && e.style.setProperty("--hue", String(t)) } function Th() { const [t, e] = Jt(Sc()), n = xc(); function r() { e(n) } return xe(() => { Ec(t) }, [t]), D(Re, { children: [D("div", { className: "mb-3 flex flex-row items-center justify-between gap-2", children: [D("div", { className: "relative ml-3 flex gap-2 text-lg font-bold text-neutral-900 transition before:absolute before:top-[0.33rem] before:-left-3 before:h-4 before:w-1 before:rounded-md before:bg-[var(--primary)] dark:text-neutral-100", children: ["Theme Color", D("button", { "aria-label": "Reset to Default", className: `btn-regular flex h-7 w-7 items-center justify-center rounded-md transition active:scale-90 ${t === n ? "pointer-events-none opacity-0" : ""}`, onClick: r, children: D("div", { className: "flex items-center justify-center text-[var(--btn-content)]", children: D("span", { className: "icon-[material-symbols--device-reset] text-[1.3rem]" }) }) })] }), D("div", { className: "flex gap-1", children: D("div", { id: "hueValue", className: "flex h-7 w-10 items-center justify-center rounded-md bg-[var(--btn-regular-bg)] text-sm font-bold text-[var(--btn-content)] transition", children: t }) })] }), D("div", { className: "h-6 w-full rounded bg-[oklch(0.80_0.10_0)] px-1 select-none dark:bg-[oklch(0.70_0.10_0)]", children: D("input", { "aria-label": "Color Picker", type: "range", min: "0", max: "360", value: t, onInput: o => e(Number(o.target.value)), className: "slider", id: "colorSlider", step: "5", style: "width: 100%" }) })] }) } function kh() { const t = sr(null), e = sr(null), [n, r] = Jt([]), [o, s] = Jt(new Map), i = Math.min(...n.map(u => u.depth), 6); let a = 1; function c() { const u = document.getElementById("content"); if (!u) return []; const d = Array.from(u.querySelectorAll("h1, h2, h3, h4")), f = new Set; return d.map(m => { let h = m.id || m.textContent?.trim().replace(/\s+/g, "-") || "", _ = h, p = 1; for (; f.has(h);)h = `${_}-${p++}`; return m.id = h, f.add(h), { id: h, text: m.textContent?.trim() || "", depth: parseInt(m.tagName[1]) } }) } xe(() => { if (n.length === 0) return; const u = n.map(m => document.getElementById(m.id)).filter(Boolean), d = new Map, f = new IntersectionObserver(m => { for (const h of m) { const _ = h.target.id; d.set(_, h.isIntersecting) } s(new Map(d)) }, { threshold: .1 }); for (const m of u) f.observe(m); return () => f.disconnect() }, [n]), xe(() => { const u = t.current, d = e.current; if (!u || !d) return; const f = Array.from(u.querySelectorAll(".visible")); if (f.length === 0) { d.classList.add("hidden"); return } const m = u.getBoundingClientRect().top, h = u.scrollTop, _ = f[0].getBoundingClientRect().top - m + h, p = f[f.length - 1].getBoundingClientRect().bottom - m + h; d.style.top = `${_}px`, d.style.height = `${p - _}px`, d.classList.remove("hidden") }, [o]), xe(() => { const u = () => r(c()); return u(), document.addEventListener("swup:contentReplaced", u), () => document.removeEventListener("swup:contentReplaced", u) }, []); const l = u => { const d = u.lastIndexOf("#"); return d === u.length - 1 ? u.substring(0, d) : u }; return D("div", { class: "group relative", id: "toc", children: [D("div", { id: "toc-inner-wrapper", ref: t, class: "max-h-[calc(100vh-100px)] overflow-y-auto", children: n.map(u => { const d = o.get(u.id), f = u.depth - i; let m = null; f === 0 ? m = D("div", { class: "flex h-5 w-5 shrink-0 items-center justify-center rounded-lg bg-[var(--toc-badge-bg)] text-xs font-bold text-[var(--btn-content)] transition", children: a++ }) : f === 1 ? m = D("div", { class: "ml-4 flex h-5 w-5 shrink-0 items-center justify-center transition", children: D("div", { class: "h-2 w-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]" }) }) : m = D("div", { class: "ml-8 flex h-5 w-5 shrink-0 items-center justify-center transition", children: D("div", { class: "h-1.5 w-1.5 rounded-sm bg-black/5 dark:bg-white/10" }) }); const h = f === 0 || f === 1 ? "text-50" : "text-30"; return D("a", { href: `#${u.id}`, class: `relative flex min-h-9 w-full gap-2 rounded-xl px-2 py-2 transition hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] ${d ? "visible" : ""}`, children: [m, D("div", { class: `text-sm transition ${h}`, children: l(u.text) })] }) }) }), D("div", { id: "active-indicator", ref: e, class: "absolute right-0 left-0 -z-10 hidden rounded-xl border-2 border-dashed border-[var(--toc-btn-hover)] bg-[var(--toc-btn-hover)] transition-all group-hover:border-[var(--toc-btn-active)] group-hover:bg-transparent" })] }) } function Ph(t) { Ar(D(Ch, {}), t) } function Oh(t) { Ar(D(Ah, {}), t) } function Ih(t) { Ar(D(Th, {}), t) } function Lh(t) { Ar(D(kh, {}), t) }/*!
 * OverlayScrollbars
 * Version: 2.12.0
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */const Et = (t, e) => { const { o: n, i: r, u: o } = t; let s = n, i; const a = (u, d) => { const f = s, m = u, h = d || (r ? !r(f, m) : f !== m); return (h || o) && (s = m, i = f), [s, h, i] }; return [e ? u => a(e(s, i), u) : a, u => [s, !!u, i]] }, Mh = typeof window < "u" && typeof HTMLElement < "u" && !!window.document, St = Mh ? window : {}, $c = Math.max, Rh = Math.min, To = Math.round, ir = Math.abs, bi = Math.sign, Cc = St.cancelAnimationFrame, ms = St.requestAnimationFrame, gs = St.setTimeout, Ac = St.clearTimeout, Tr = t => typeof St[t] < "u" ? St[t] : void 0, Nh = Tr("MutationObserver"), xi = Tr("IntersectionObserver"), ve = Tr("ResizeObserver"), Ke = Tr("ScrollTimeline"), _s = t => t === void 0, kr = t => t === null, Kt = t => typeof t == "number", hn = t => typeof t == "string", Pr = t => typeof t == "boolean", Nt = t => typeof t == "function", Lt = t => Array.isArray(t), ar = t => typeof t == "object" && !Lt(t) && !kr(t), vs = t => { const e = !!t && t.length, n = Kt(e) && e > -1 && e % 1 == 0; return Lt(t) || !Nt(t) && n ? e > 0 && ar(t) ? e - 1 in t : !0 : !1 }, cr = t => !!t && t.constructor === Object, lr = t => t instanceof HTMLElement, Or = t => t instanceof Element; function J(t, e) { if (vs(t)) for (let n = 0; n < t.length && e(t[n], n, t) !== !1; n++); else t && J(Object.keys(t), (n => e(t[n], n, t))); return t } const Tc = (t, e) => t.indexOf(e) >= 0, on = (t, e) => t.concat(e), it = (t, e, n) => (!hn(e) && vs(e) ? Array.prototype.push.apply(t, e) : t.push(e), t), oe = t => Array.from(t || []), ys = t => Lt(t) ? t : !hn(t) && vs(t) ? oe(t) : [t], ur = t => !!t && !t.length, ko = t => oe(new Set(t)), Ct = (t, e, n) => { J(t, o => o ? o.apply(void 0, e || []) : !0), n || (t.length = 0) }, kc = "paddingTop", Pc = "paddingRight", Oc = "paddingLeft", Ic = "paddingBottom", Lc = "marginLeft", Mc = "marginRight", Rc = "marginBottom", ws = "overflowX", bs = "overflowY", Ir = "width", Lr = "height", Vt = "visible", Ot = "hidden", Te = "scroll", Hh = t => { const e = String(t || ""); return e ? e[0].toUpperCase() + e.slice(1) : "" }, Mr = (t, e, n, r) => { if (t && e) { let o = !0; return J(n, (s => { const i = t[s], a = e[s]; i !== a && (o = !1) })), o } return !1 }, Nc = (t, e) => Mr(t, e, ["w", "h"]), Kn = (t, e) => Mr(t, e, ["x", "y"]), Dh = (t, e) => Mr(t, e, ["t", "r", "b", "l"]), F = (t, ...e) => t.bind(0, ...e), ye = t => { let e; const n = t ? gs : ms, r = t ? Ac : Cc; return [o => { r(e), e = n((() => o()), Nt(t) ? t() : t) }, () => r(e)] }, Si = t => { const e = Nt(t) ? t() : t; if (Kt(e)) { const n = e ? gs : ms, r = e ? Ac : Cc; return o => { const s = n((() => o()), e); return () => { r(s) } } } return e && e._ }, dr = (t, e) => { const { p: n, v: r, S: o, m: s } = e || {}; let i, a, c, l; const u = function (_) { a && a(), i && i(), l = a = i = c = void 0, t.apply(this, _) }, d = h => s && c ? s(c, h) : h, f = () => { a && c && u(d(c) || c) }, m = function () { const _ = oe(arguments), p = Si(n); if (p) { const g = Si(r), b = d(_) || _, w = u.bind(0, b); a && a(), o && !l ? (w(), l = !0, a = p((() => l = void 0))) : (a = p(w), g && !i && (i = g(f))), c = b } else u(_) }; return m.O = f, m }, Hc = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Mt = t => t ? Object.keys(t) : [], X = (t, e, n, r, o, s, i) => { const a = [e, n, r, o, s, i]; return (typeof t != "object" || kr(t)) && !Nt(t) && (t = {}), J(a, (c => { J(c, ((l, u) => { const d = c[u]; if (t === d) return !0; const f = Lt(d); if (d && cr(d)) { const m = t[u]; let h = m; f && !Lt(m) ? h = [] : !f && !cr(m) && (h = {}), t[u] = X(h, d) } else t[u] = f ? d.slice() : d })) })), t }, Dc = (t, e) => J(X({}, t), ((n, r, o) => { n === void 0 ? delete o[r] : n && cr(n) && (o[r] = Dc(n)) })), xs = t => !Mt(t).length, sn = () => { }, Bc = (t, e, n) => $c(t, Rh(e, n)), pe = t => ko((Lt(t) ? t : (t || "").split(" ")).filter((e => e))), Ss = (t, e) => t && t.getAttribute(e), Ei = (t, e) => t && t.hasAttribute(e), Ft = (t, e, n) => { J(pe(e), (r => { t && t.setAttribute(r, String(n || "")) })) }, Ht = (t, e) => { J(pe(e), (n => t && t.removeAttribute(n))) }, Rr = (t, e) => { const n = pe(Ss(t, e)), r = F(Ft, t, e), o = (s, i) => { const a = new Set(n); return J(pe(s), (c => { a[i](c) })), oe(a).join(" ") }; return { C: s => r(o(s, "delete")), $: s => r(o(s, "add")), H: s => { const i = pe(s); return i.reduce(((a, c) => a && n.includes(c)), i.length > 0) } } }, jc = (t, e, n) => (Rr(t, e).C(n), F(Es, t, e, n)), Es = (t, e, n) => (Rr(t, e).$(n), F(jc, t, e, n)), hr = (t, e, n, r) => (r ? Es : jc)(t, e, n), $s = (t, e, n) => Rr(t, e).H(n), qc = t => Rr(t, "class"), Fc = (t, e) => { qc(t).C(e) }, Cs = (t, e) => (qc(t).$(e), F(Fc, t, e)), zc = (t, e) => { const n = e ? Or(e) && e : document; return n ? oe(n.querySelectorAll(t)) : [] }, Bh = (t, e) => { const n = e ? Or(e) && e : document; return n && n.querySelector(t) }, Po = (t, e) => Or(t) && t.matches(e), Vc = t => Po(t, "body"), Oo = t => t ? oe(t.childNodes) : [], an = t => t && t.parentElement, we = (t, e) => Or(t) && t.closest(e), Io = t => document.activeElement, jh = (t, e, n) => { const r = we(t, e), o = t && Bh(n, r), s = we(o, e) === r; return r && o ? r === t || o === t || s && we(we(t, n), e) !== r : !1 }, ke = t => { J(ys(t), (e => { const n = an(e); e && n && n.removeChild(e) })) }, xt = (t, e) => F(ke, t && e && J(ys(e), (n => { n && t.appendChild(n) }))); let Uc; const qh = () => Uc, Fh = t => { Uc = t }, Se = t => { const e = document.createElement("div"); return Ft(e, "class", t), e }, Wc = t => { const e = Se(), n = qh(), r = t.trim(); return e.innerHTML = n ? n.createHTML(r) : r, J(Oo(e), (o => ke(o))) }, $i = (t, e) => t.getPropertyValue(e) || t[e] || "", Kc = t => { const e = t || 0; return isFinite(e) ? e : 0 }, Dn = t => Kc(parseFloat(t || "")), Lo = t => Math.round(t * 1e4) / 1e4, Gc = t => `${Lo(Kc(t))}px`; function cn(t, e) { t && e && J(e, ((n, r) => { try { const o = t.style, s = kr(n) || Pr(n) ? "" : Kt(n) ? Gc(n) : n; r.indexOf("--") === 0 ? o.setProperty(r, s) : o[r] = s } catch { } })) } function jt(t, e, n) { const r = hn(e); let o = r ? "" : {}; if (t) { const s = St.getComputedStyle(t, n) || t.style; o = r ? $i(s, e) : oe(e).reduce(((i, a) => (i[a] = $i(s, a), i)), o) } return o } const Ci = (t, e, n) => { const r = e ? `${e}-` : "", o = n ? `-${n}` : "", s = `${r}top${o}`, i = `${r}right${o}`, a = `${r}bottom${o}`, c = `${r}left${o}`, l = jt(t, [s, i, a, c]); return { t: Dn(l[s]), r: Dn(l[i]), b: Dn(l[a]), l: Dn(l[c]) } }, Jr = (t, e) => `translate${ar(t) ? `(${t.x},${t.y})` : `${e ? "X" : "Y"}(${t})`}`, zh = t => !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length), Vh = { w: 0, h: 0 }, Nr = (t, e) => e ? { w: e[`${t}Width`], h: e[`${t}Height`] } : Vh, Uh = t => Nr("inner", t || St), Ee = F(Nr, "offset"), Zc = F(Nr, "client"), fr = F(Nr, "scroll"), As = t => { const e = parseFloat(jt(t, Ir)) || 0, n = parseFloat(jt(t, Lr)) || 0; return { w: e - To(e), h: n - To(n) } }, Qr = t => t.getBoundingClientRect(), Wh = t => !!t && zh(t), Mo = t => !!(t && (t[Lr] || t[Ir])), Xc = (t, e) => { const n = Mo(t); return !Mo(e) && n }, Ai = (t, e, n, r) => { J(pe(e), (o => { t && t.removeEventListener(o, n, r) })) }, rt = (t, e, n, r) => { var o; const s = (o = r && r.T) != null ? o : !0, i = r && r.I || !1, a = r && r.A || !1, c = { passive: s, capture: i }; return F(Ct, pe(e).map((l => { const u = a ? d => { Ai(t, l, u, i), n && n(d) } : n; return t && t.addEventListener(l, u, c), F(Ai, t, l, u, i) }))) }, Yc = t => t.stopPropagation(), Ro = t => t.preventDefault(), Jc = t => Yc(t) || Ro(t), Bt = (t, e) => { const { x: n, y: r } = Kt(e) ? { x: e, y: e } : e || {}; Kt(n) && (t.scrollLeft = n), Kt(r) && (t.scrollTop = r) }, $t = t => ({ x: t.scrollLeft, y: t.scrollTop }), Qc = () => ({ D: { x: 0, y: 0 }, M: { x: 0, y: 0 } }), Kh = (t, e) => { const { D: n, M: r } = t, { w: o, h: s } = e, i = (d, f, m) => { let h = bi(d) * m, _ = bi(f) * m; if (h === _) { const p = ir(d), g = ir(f); _ = p > g ? 0 : _, h = p < g ? 0 : h } return h = h === _ ? 0 : h, [h + 0, _ + 0] }, [a, c] = i(n.x, r.x, o), [l, u] = i(n.y, r.y, s); return { D: { x: a, y: l }, M: { x: c, y: u } } }, to = ({ D: t, M: e }) => { const n = (r, o) => r === 0 && r <= o; return { x: n(t.x, e.x), y: n(t.y, e.y) } }, Ti = ({ D: t, M: e }, n) => { const r = (o, s, i) => Bc(0, 1, (o - i) / (o - s) || 0); return { x: r(t.x, e.x, n.x), y: r(t.y, e.y, n.y) } }, No = t => { t && t.focus && t.focus({ preventScroll: !0 }) }, ki = (t, e) => { J(ys(e), t) }, Ho = t => { const e = new Map, n = (s, i) => { if (s) { const a = e.get(s); ki((c => { a && a[c ? "delete" : "clear"](c) }), i) } else e.forEach((a => { a.clear() })), e.clear() }, r = (s, i) => { if (hn(s)) { const l = e.get(s) || new Set; return e.set(s, l), ki((u => { Nt(u) && l.add(u) }), i), F(n, s, i) } Pr(i) && i && n(); const a = Mt(s), c = []; return J(a, (l => { const u = s[l]; u && it(c, r(l, u)) })), F(Ct, c) }, o = (s, i) => { J(oe(e.get(s)), (a => { i && !ur(i) ? a.apply(0, i) : a() })) }; return r(t || {}), [r, n, o] }, tl = {}, el = {}, Gh = t => { J(t, (e => J(e, ((n, r) => { tl[r] = e[r] })))) }, nl = (t, e, n) => Mt(t).map((r => { const { static: o, instance: s } = t[r], [i, a, c] = n || [], l = n ? s : o; if (l) { const u = n ? l(i, a, e) : l(e); return (c || el)[r] = u } })), Ne = t => el[t], Zh = "__osOptionsValidationPlugin", He = "data-overlayscrollbars", Gn = "os-environment", Bn = `${Gn}-scrollbar-hidden`, eo = `${He}-initialize`, Zn = "noClipping", Pi = `${He}-body`, Qt = He, Xh = "host", zt = `${He}-viewport`, Yh = ws, Jh = bs, Qh = "arrange", rl = "measuring", tf = "scrolling", ol = "scrollbarHidden", ef = "noContent", Do = `${He}-padding`, Oi = `${He}-content`, Ts = "os-size-observer", nf = `${Ts}-appear`, ks = `${Ts}-listener`, Np = `${ks}-scroll`, rf = `${ks}-item`, Hp = `${rf}-final`, of = "os-trinsic-observer", sf = "os-theme-none", At = "os-scrollbar", af = `${At}-rtl`, cf = `${At}-horizontal`, lf = `${At}-vertical`, sl = `${At}-track`, Ps = `${At}-handle`, uf = `${At}-visible`, df = `${At}-cornerless`, Ii = `${At}-interaction`, Li = `${At}-unusable`, Bo = `${At}-auto-hide`, Mi = `${Bo}-hidden`, Ri = `${At}-wheel`, hf = `${sl}-interactive`, ff = `${Ps}-interactive`, pf = "__osSizeObserverPlugin"; const mf = (t, e) => { const { k: n } = e, [r, o] = t("showNativeOverlaidScrollbars"); return [r && n.x && n.y, o] }, be = t => t.indexOf(Vt) === 0, gf = t => t.replace(`${Vt}-`, ""), jo = (t, e) => { if (t === "auto") return e ? Te : Ot; const n = t || Ot; return [Ot, Te, Vt].includes(n) ? n : Ot }, _f = (t, e) => { const { overflowX: n, overflowY: r } = jt(t, [ws, bs]); return { x: jo(n, e.x), y: jo(r, e.y) } }, Os = "__osScrollbarsHidingPlugin"; const vf = "__osClickScrollPlugin"; const Ni = t => JSON.stringify(t, ((e, n) => { if (Nt(n)) throw 0; return n })), Hi = (t, e) => t ? `${e}`.split(".").reduce(((n, r) => n && Hc(n, r) ? n[r] : void 0), t) : void 0, yf = { paddingAbsolute: !1, showNativeOverlaidScrollbars: !1, update: { elementEvents: [["img", "load"]], debounce: [0, 33], attributes: null, ignoreMutation: null }, overflow: { x: "scroll", y: "scroll" }, scrollbars: { theme: "os-theme-dark", visibility: "auto", autoHide: "never", autoHideDelay: 1300, autoHideSuspend: !1, dragScroll: !0, clickScroll: !1, pointers: ["mouse", "touch", "pen"] } }, il = (t, e) => { const n = {}, r = on(Mt(e), Mt(t)); return J(r, (o => { const s = t[o], i = e[o]; if (ar(s) && ar(i)) X(n[o] = {}, il(s, i)), xs(n[o]) && delete n[o]; else if (Hc(e, o) && i !== s) { let a = !0; if (Lt(s) || Lt(i)) try { Ni(s) === Ni(i) && (a = !1) } catch { } a && (n[o] = i) } })), n }, Di = (t, e, n) => r => [Hi(t, r), n || Hi(e, r) !== void 0]; let al; const wf = () => al, bf = t => { al = t }; let no; const xf = () => { const t = (w, k, P) => { xt(document.body, w), xt(document.body, w); const M = Zc(w), j = Ee(w), O = As(k); return P && ke(w), { x: j.h - M.h + O.h, y: j.w - M.w + O.w } }, e = w => { let k = !1; const P = Cs(w, Bn); try { k = jt(w, "scrollbar-width") === "none" || jt(w, "display", "::-webkit-scrollbar") === "none" } catch { } return P(), k }, n = `.${Gn}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${Gn} div{width:200%;height:200%;margin:10px 0}.${Bn}{scrollbar-width:none!important}.${Bn}::-webkit-scrollbar,.${Bn}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, o = Wc(`<div class="${Gn}"><div></div><style>${n}</style></div>`)[0], s = o.firstChild, i = o.lastChild, a = wf(); a && (i.nonce = a); const [c, , l] = Ho(), [u, d] = Et({ o: t(o, s), i: Kn }, F(t, o, s, !0)), [f] = d(), m = e(o), h = { x: f.x === 0, y: f.y === 0 }, _ = { elements: { host: null, padding: !m, viewport: w => m && Vc(w) && w, content: !1 }, scrollbars: { slot: !0 }, cancel: { nativeScrollbarsOverlaid: !1, body: null } }, p = X({}, yf), g = F(X, {}, p), v = F(X, {}, _), b = { P: f, k: h, U: m, J: !!Ke, G: F(c, "r"), K: v, Z: w => X(_, w) && v(), tt: g, nt: w => X(p, w) && g(), ot: X({}, _), st: X({}, p) }; if (Ht(o, "style"), ke(o), rt(St, "resize", (() => { l("r", []) })), Nt(St.matchMedia) && !m && (!h.x || !h.y)) { const w = k => { const P = St.matchMedia(`(resolution: ${St.devicePixelRatio}dppx)`); rt(P, "change", (() => { k(), w(k) }), { A: !0 }) }; w((() => { const [k, P] = u(); X(b.P, k), l("r", [P]) })) } return b }, qt = () => (no || (no = xf()), no), Sf = (t, e, n) => { let r = !1; const o = n ? new WeakMap : !1, s = () => { r = !0 }, i = a => { if (o && n) { const c = n.map((l => { const [u, d] = l || []; return [d && u ? (a || zc)(u, t) : [], d] })); J(c, (l => J(l[0], (u => { const d = l[1], f = o.get(u) || []; if (t.contains(u) && d) { const h = rt(u, d, (_ => { r ? (h(), o.delete(u)) : e(_) })); o.set(u, it(f, h)) } else Ct(f), o.delete(u) })))) } }; return i(), [s, i] }, Bi = (t, e, n, r) => { let o = !1; const { et: s, ct: i, rt: a, it: c, lt: l, ut: u } = r || {}, d = dr((() => o && n(!0)), { p: 33, v: 99 }), [f, m] = Sf(t, d, a), h = s || [], _ = i || [], p = on(h, _), g = (b, w) => { if (!ur(w)) { const k = l || sn, P = u || sn, M = [], j = []; let O = !1, E = !1; if (J(w, (C => { const { attributeName: A, target: N, type: q, oldValue: K, addedNodes: U, removedNodes: I } = C, Z = q === "attributes", W = q === "childList", Q = t === N, R = Z && A, B = R && Ss(N, A || ""), y = hn(B) ? B : null, $ = R && K !== y, x = Tc(_, A) && $; if (e && (W || !Q)) { const S = Z && $, T = S && c && Po(N, c), H = (T ? !k(N, A, K, y) : !Z || S) && !P(C, !!T, t, r); J(U, (z => it(M, z))), J(I, (z => it(M, z))), E = E || H } !e && Q && $ && !k(N, A, K, y) && (it(j, A), O = O || x) })), m((C => ko(M).reduce(((A, N) => (it(A, zc(C, N)), Po(N, C) ? it(A, N) : A)), []))), e) return !b && E && n(!1), [!1]; if (!ur(j) || O) { const C = [ko(j), O]; return b || n.apply(0, C), C } } }, v = new Nh(F(g, !1)); return [() => (v.observe(t, { attributes: !0, attributeOldValue: !0, attributeFilter: p, subtree: e, childList: e, characterData: e }), o = !0, () => { o && (f(), v.disconnect(), o = !1) }), () => { if (o) return d.O(), g(!0, v.takeRecords()) }] }; let ie = null; const cl = (t, e, n) => { const { ft: r } = n || {}, o = Ne(pf), [s] = Et({ o: !1, u: !0 }); return () => { const i = [], c = Wc(`<div class="${Ts}"><div class="${ks}"></div></div>`)[0], l = c.firstChild, u = d => { const f = Lt(d) && !ur(d); let m = !1, h = !1; if (f) { const _ = d[0], [p, , g] = s(_.contentRect), v = Mo(p); h = Xc(p, g), m = !h && !v } else h = d === !0; m || e({ _t: !0, ft: h }) }; if (ve) { if (!Pr(ie)) { const h = new ve(sn); h.observe(t, { get box() { ie = !0 } }), ie = ie || !1, h.disconnect() } const d = dr(u, { p: 0, v: 0 }), f = h => d(h), m = new ve(f); if (m.observe(ie ? t : l), it(i, [() => { m.disconnect() }, !ie && xt(t, c)]), ie) { const h = new ve(f); h.observe(t, { box: "border-box" }), it(i, (() => h.disconnect())) } } else if (o) { const [d, f] = o(l, u, r); it(i, on([Cs(c, nf), rt(c, "animationstart", d), xt(t, c)], f)) } else return sn; return F(Ct, i) } }, Ef = (t, e) => { let n; const r = c => c.h === 0 || c.isIntersecting || c.intersectionRatio > 0, o = Se(of), [s] = Et({ o: !1 }), i = (c, l) => { if (c) { const u = s(r(c)), [, d] = u; return d && !l && e(u) && [u] } }, a = (c, l) => i(l.pop(), c); return [() => { const c = []; if (xi) n = new xi(F(a, !1), { root: t }), n.observe(o), it(c, (() => { n.disconnect() })); else { const l = () => { const u = Ee(o); i(u) }; it(c, cl(o, l)()), l() } return F(Ct, it(c, xt(t, o))) }, () => n && a(!0, n.takeRecords())] }, $f = (t, e, n, r) => { let o, s, i, a, c, l; const u = `[${Qt}]`, d = `[${zt}]`, f = ["id", "class", "style", "open", "wrap", "cols", "rows"], { dt: m, vt: h, L: _, gt: p, ht: g, V: v, bt: b, wt: w, yt: k, St: P } = t, M = x => jt(x, "direction") === "rtl", j = { Ot: !1, B: M(m) }, O = qt(), E = Ne(Os), [C] = Et({ i: Nc, o: { w: 0, h: 0 } }, (() => { const x = E && E.R(t, e, j, O, n).Y, T = !(b && v) && $s(h, Qt, Zn), L = !v && w(Qh), H = L && $t(p), z = H && P(), Y = k(rl, T), G = L && x && x(), tt = fr(_), V = As(_); return G && G(), Bt(p, H), z && z(), T && Y(), { w: tt.w + V.w, h: tt.h + V.h } })), A = dr(r, { p: () => o, v: () => s, m(x, S) { const [T] = x, [L] = S; return [on(Mt(T), Mt(L)).reduce(((H, z) => (H[z] = T[z] || L[z], H)), {})] } }), N = x => { const S = M(m); X(x, { Ct: l !== S }), X(j, { B: S }), l = S }, q = (x, S) => { const [T, L] = x, H = { $t: L }; return X(j, { Ot: T }), S || r(H), H }, K = ({ _t: x, ft: S }) => { const L = !(x && !S) && O.U ? A : r, H = { _t: x || S, ft: S }; N(H), L(H) }, U = (x, S) => { const [, T] = C(), L = { xt: T }; return N(L), T && !S && (x ? r : A)(L), L }, I = (x, S, T) => { const L = { Ht: S }; return N(L), S && !T && A(L), L }, [Z, W] = g ? Ef(h, q) : [], Q = !v && cl(h, K, { ft: !0 }), [R, B] = Bi(h, !1, I, { ct: f, et: f }), y = v && ve && new ve((x => { const S = x[x.length - 1].contentRect; K({ _t: !0, ft: Xc(S, c) }), c = S })), $ = dr((() => { const [, x] = C(); r({ xt: x, _t: b }) }), { p: 222, S: !0 }); return [() => { y && y.observe(h); const x = Q && Q(), S = Z && Z(), T = R(), L = O.G((H => { H ? A({ Et: H }) : $() })); return () => { y && y.disconnect(), x && x(), S && S(), a && a(), T(), L() } }, ({ zt: x, Tt: S, It: T }) => { const L = {}, [H] = x("update.ignoreMutation"), [z, Y] = x("update.attributes"), [G, tt] = x("update.elementEvents"), [V, ht] = x("update.debounce"), mt = tt || Y, ut = S || T, wt = st => Nt(H) && H(st); if (mt) { i && i(), a && a(); const [st, ct] = Bi(g || _, !0, U, { et: on(f, z || []), rt: G, it: u, ut: (lt, nt) => { const { target: _t, attributeName: yt } = lt; return (!nt && yt && !v ? jh(_t, u, d) : !1) || !!we(_t, `.${At}`) || !!wt(lt) } }); a = st(), i = ct } if (ht) if (A.O(), Lt(V)) { const st = V[0], ct = V[1]; o = Kt(st) && st, s = Kt(ct) && ct } else Kt(V) ? (o = V, s = !1) : (o = !1, s = !1); if (ut) { const st = B(), ct = W && W(), lt = i && i(); st && X(L, I(st[0], st[1], ut)), ct && X(L, q(ct[0], ut)), lt && X(L, U(lt[0], ut)) } return N(L), L }, j] }, ll = (t, e) => Nt(e) ? e.apply(0, t) : e, Cf = (t, e, n, r) => { const o = _s(r) ? n : r; return ll(t, o) || e.apply(0, t) }, ul = (t, e, n, r) => { const o = _s(r) ? n : r, s = ll(t, o); return !!s && (lr(s) ? s : e.apply(0, t)) }, Af = (t, e) => { const { nativeScrollbarsOverlaid: n, body: r } = e || {}, { k: o, U: s, K: i } = qt(), { nativeScrollbarsOverlaid: a, body: c } = i().cancel, l = n ?? a, u = _s(r) ? c : r, d = (o.x || o.y) && l, f = t && (kr(u) ? !s : u); return !!d || !!f }, Tf = (t, e, n, r) => { const o = "--os-viewport-percent", s = "--os-scroll-percent", i = "--os-scroll-direction", { K: a } = qt(), { scrollbars: c } = a(), { slot: l } = c, { dt: u, vt: d, L: f, At: m, gt: h, bt: _, V: p } = e, { scrollbars: g } = m ? {} : t, { slot: v } = g || {}, b = [], w = [], k = [], P = ul([u, d, f], (() => p && _ ? u : d), l, v), M = R => { if (Ke) { let B = null, y = []; const $ = new Ke({ source: h, axis: R }), x = () => { B && B.cancel(), B = null }; return { kt: T => { const { Dt: L } = n, H = to(L)[R], z = R === "x", Y = [Jr(0, z), Jr(`calc(100cq${z ? "w" : "h"} + -100%)`, z)], G = H ? Y : Y.reverse(); return y[0] === G[0] && y[1] === G[1] || (x(), y = G, B = T.Mt.animate({ clear: ["left"], transform: G }, { timeline: $ })), x } } } }, j = { x: M("x"), y: M("y") }, O = () => { const { Rt: R, Vt: B } = n, y = ($, x) => Bc(0, 1, $ / ($ + x) || 0); return { x: y(B.x, R.x), y: y(B.y, R.y) } }, E = (R, B, y) => { const $ = y ? Cs : Fc; J(R, (x => { $(x.Lt, B) })) }, C = (R, B) => { J(R, (y => { const [$, x] = B(y); cn($, x) })) }, A = (R, B, y) => { const $ = Pr(y), x = $ ? y : !0, S = $ ? !y : !0; x && E(w, R, B), S && E(k, R, B) }, N = () => { const R = O(), B = y => $ => [$.Lt, { [o]: Lo(y) + "" }]; C(w, B(R.x)), C(k, B(R.y)) }, q = () => { if (!Ke) { const { Dt: R } = n, B = Ti(R, $t(h)), y = $ => x => [x.Lt, { [s]: Lo($) + "" }]; C(w, y(B.x)), C(k, y(B.y)) } }, K = () => { const { Dt: R } = n, B = to(R), y = $ => x => [x.Lt, { [i]: $ ? "0" : "1" }]; C(w, y(B.x)), C(k, y(B.y)), Ke && (w.forEach(j.x.kt), k.forEach(j.y.kt)) }, U = () => { if (p && !_) { const { Rt: R, Dt: B } = n, y = to(B), $ = Ti(B, $t(h)), x = S => { const { Lt: T } = S, L = an(T) === f && T, H = (z, Y, G) => { const tt = Y * z; return Gc(G ? tt : -tt) }; return [L, L && { transform: Jr({ x: H($.x, R.x, y.x), y: H($.y, R.y, y.y) }) }] }; C(w, x), C(k, x) } }, I = R => { const B = R ? "x" : "y", $ = Se(`${At} ${R ? cf : lf}`), x = Se(sl), S = Se(Ps), T = { Lt: $, Ut: x, Mt: S }, L = j[B]; return it(R ? w : k, T), it(b, [xt($, x), xt(x, S), F(ke, $), L && L.kt(T), r(T, A, R)]), T }, Z = F(I, !0), W = F(I, !1), Q = () => (xt(P, w[0].Lt), xt(P, k[0].Lt), F(Ct, b)); return Z(), W(), [{ Pt: N, Nt: q, qt: K, Bt: U, Ft: A, jt: { Xt: w, Yt: Z, Wt: F(C, w) }, Jt: { Xt: k, Yt: W, Wt: F(C, k) } }, Q] }, kf = (t, e, n, r) => (o, s, i) => { const { vt: a, L: c, V: l, gt: u, Gt: d, St: f } = e, { Lt: m, Ut: h, Mt: _ } = o, [p, g] = ye(333), [v, b] = ye(444), w = M => { Nt(u.scrollBy) && u.scrollBy({ behavior: "smooth", left: M.x, top: M.y }) }, k = () => { const M = "pointerup pointercancel lostpointercapture", j = `client${i ? "X" : "Y"}`, O = i ? Ir : Lr, E = i ? "left" : "top", C = i ? "w" : "h", A = i ? "x" : "y", N = (K, U) => I => { const { Rt: Z } = n, W = Ee(h)[C] - Ee(_)[C], R = U * I / W * Z[A]; Bt(u, { [A]: K + R }) }, q = []; return rt(h, "pointerdown", (K => { const U = we(K.target, `.${Ps}`) === _, I = U ? _ : h, Z = t.scrollbars, W = Z[U ? "dragScroll" : "clickScroll"], { button: Q, isPrimary: R, pointerType: B } = K, { pointers: y } = Z; if (Q === 0 && R && W && (y || []).includes(B)) { Ct(q), b(); const x = !U && (K.shiftKey || W === "instant"), S = F(Qr, _), T = F(Qr, h), L = (nt, _t) => (nt || S())[E] - (_t || T())[E], H = To(Qr(u)[O]) / Ee(u)[C] || 1, z = N($t(u)[A], 1 / H), Y = K[j], G = S(), tt = T(), V = G[O], ht = L(G, tt) + V / 2, mt = Y - tt[E], ut = U ? 0 : mt - ht, wt = nt => { Ct(lt), I.releasePointerCapture(nt.pointerId) }, st = U || x, ct = f(), lt = [rt(d, M, wt), rt(d, "selectstart", (nt => Ro(nt)), { T: !1 }), rt(h, M, wt), st && rt(h, "pointermove", (nt => z(ut + (nt[j] - Y)))), st && (() => { const nt = $t(u); ct(); const _t = $t(u), yt = { x: _t.x - nt.x, y: _t.y - nt.y }; (ir(yt.x) > 3 || ir(yt.y) > 3) && (f(), Bt(u, nt), w(yt), v(ct)) })]; if (I.setPointerCapture(K.pointerId), x) z(ut); else if (!U) { const nt = Ne(vf); if (nt) { const _t = nt(z, ut, V, (yt => { yt ? ct() : it(lt, ct) })); it(lt, _t), it(q, F(_t, !0)) } } } })) }; let P = !0; return F(Ct, [rt(_, "pointermove pointerleave", r), rt(m, "pointerenter", (() => { s(Ii, !0) })), rt(m, "pointerleave pointercancel", (() => { s(Ii, !1) })), !l && rt(m, "mousedown", (() => { const M = Io(); (Ei(M, zt) || Ei(M, Qt) || M === document.body) && gs(F(No, c), 25) })), rt(m, "wheel", (M => { const { deltaX: j, deltaY: O, deltaMode: E } = M; P && E === 0 && an(m) === a && w({ x: j, y: O }), P = !1, s(Ri, !0), p((() => { P = !0, s(Ri) })), Ro(M) }), { T: !1, I: !0 }), rt(m, "pointerdown", (() => { const M = rt(d, "click", (O => { j(), Jc(O) }), { A: !0, I: !0, T: !1 }), j = rt(d, "pointerup pointercancel", (() => { j(), setTimeout(M, 150) }), { I: !0, T: !0 }) }), { I: !0, T: !0 }), k(), g, b]) }, Pf = (t, e, n, r, o, s) => { let i, a, c, l, u, d = sn, f = 0; const m = ["mouse", "pen"], h = y => m.includes(y.pointerType), [_, p] = ye(), [g, v] = ye(100), [b, w] = ye(100), [k, P] = ye((() => f)), [M, j] = Tf(t, o, r, kf(e, o, r, (y => h(y) && Z()))), { vt: O, Kt: E, bt: C } = o, { Ft: A, Pt: N, Nt: q, qt: K, Bt: U } = M, I = (y, $) => { if (P(), y) A(Mi); else { const x = F(A, Mi, !0); f > 0 && !$ ? k(x) : x() } }, Z = () => { (c ? !i : !l) && (I(!0), g((() => { I(!1) }))) }, W = y => { A(Bo, y, !0), A(Bo, y, !1) }, Q = y => { h(y) && (i = c, c && I(!0)) }, R = [P, v, w, p, () => d(), rt(O, "pointerover", Q, { A: !0 }), rt(O, "pointerenter", Q), rt(O, "pointerleave", (y => { h(y) && (i = !1, c && I(!1)) })), rt(O, "pointermove", (y => { h(y) && a && Z() })), rt(E, "scroll", (y => { _((() => { q(), Z() })), s(y), U() }))], B = Ne(Os); return [() => F(Ct, it(R, j())), ({ zt: y, It: $, Qt: x, Zt: S }) => { const { tn: T, nn: L, sn: H, en: z } = S || {}, { Ct: Y, ft: G } = x || {}, { B: tt } = n, { k: V, U: ht } = qt(), { cn: mt, j: ut } = r, [wt, st] = y("showNativeOverlaidScrollbars"), [ct, lt] = y("scrollbars.theme"), [nt, _t] = y("scrollbars.visibility"), [yt, De] = y("scrollbars.autoHide"), [Be, fn] = y("scrollbars.autoHideSuspend"), [pn] = y("scrollbars.autoHideDelay"), [mn, gn] = y("scrollbars.dragScroll"), [se, je] = y("scrollbars.clickScroll"), [_n, Dr] = y("overflow"), Br = G && !$, jr = ut.x || ut.y, Pt = T || L || z || Y || $, qr = H || _t || Dr, vn = wt && V.x && V.y, yn = !ht && !B, Fr = vn || yn, wn = (qe, Fe, bn) => { const Xt = qe.includes(Te) && (nt === Vt || nt === "auto" && Fe === Te); return A(uf, Xt, bn), Xt }; if (f = pn, Br && (Be && jr ? (W(!1), d(), b((() => { d = rt(E, "scroll", F(W, !0), { A: !0 }) }))) : W(!0)), (st || yn) && A(sf, Fr), lt && (A(u), A(ct, !0), u = ct), fn && !Be && W(!0), De && (a = yt === "move", c = yt === "leave", l = yt === "never", I(l, !0)), gn && A(ff, mn), je && A(hf, !!se), qr) { const qe = wn(_n.x, mt.x, !0), Fe = wn(_n.y, mt.y, !1); A(df, !(qe && Fe)) } Pt && (q(), N(), U(), z && K(), A(Li, !ut.x, !0), A(Li, !ut.y, !1), A(af, tt && !C)) }, {}, M] }, Of = t => { const e = qt(), { K: n, U: r } = e, { elements: o } = n(), { padding: s, viewport: i, content: a } = o, c = lr(t), l = c ? {} : t, { elements: u } = l, { padding: d, viewport: f, content: m } = u || {}, h = c ? t : l.target, _ = Vc(h), p = h.ownerDocument, g = p.documentElement, v = () => p.defaultView || St, b = F(Cf, [h]), w = F(ul, [h]), k = F(Se, ""), P = F(b, k, i), M = F(w, k, a), j = V => { const ht = Ee(V), mt = fr(V), ut = jt(V, ws), wt = jt(V, bs); return mt.w - ht.w > 0 && !be(ut) || mt.h - ht.h > 0 && !be(wt) }, O = P(f), E = O === h, C = E && _, A = !E && M(m), N = !E && O === A, q = C ? g : O, K = C ? q : h, U = !E && w(k, s, d), I = !N && A, Z = [I, q, U, K].map((V => lr(V) && !an(V) && V)), W = V => V && Tc(Z, V), Q = !W(q) && j(q) ? q : h, R = C ? g : q, y = { dt: h, vt: K, L: q, rn: U, ht: I, gt: R, Kt: C ? p : q, ln: _ ? g : Q, Gt: p, bt: _, At: c, V: E, an: v, wt: V => $s(q, zt, V), yt: (V, ht) => hr(q, zt, V, ht), St: () => hr(R, zt, tf, !0) }, { dt: $, vt: x, rn: S, L: T, ht: L } = y, H = [() => { Ht(x, [Qt, eo]), Ht($, eo), _ && Ht(g, [eo, Qt]) }]; let z = Oo([L, T, S, x, $].find((V => V && !W(V)))); const Y = C ? $ : L || T, G = F(Ct, H); return [y, () => { const V = v(), ht = Io(), mt = lt => { xt(an(lt), Oo(lt)), ke(lt) }, ut = lt => rt(lt, "focusin focusout focus blur", Jc, { I: !0, T: !1 }), wt = "tabindex", st = Ss(T, wt), ct = ut(ht); return Ft(x, Qt, E ? "" : Xh), Ft(S, Do, ""), Ft(T, zt, ""), Ft(L, Oi, ""), E || (Ft(T, wt, st || "-1"), _ && Ft(g, Pi, "")), xt(Y, z), xt(x, S), xt(S || x, !E && T), xt(T, L), it(H, [ct, () => { const lt = Io(), nt = W(T), _t = nt && lt === T ? $ : lt, yt = ut(_t); Ht(S, Do), Ht(L, Oi), Ht(T, zt), _ && Ht(g, Pi), st ? Ft(T, wt, st) : Ht(T, wt), W(L) && mt(L), nt && mt(T), W(S) && mt(S), No(_t), yt() }]), r && !E && (Es(T, zt, ol), it(H, F(Ht, T, zt))), No(!E && _ && ht === $ && V.top === V ? T : ht), ct(), z = 0, G }, G] }, If = ({ ht: t }) => ({ Qt: e, un: n, It: r }) => { const { $t: o } = e || {}, { Ot: s } = n; t && (o || r) && cn(t, { [Lr]: s && "100%" }) }, Lf = ({ vt: t, rn: e, L: n, V: r }, o) => { const [s, i] = Et({ i: Dh, o: Ci() }, F(Ci, t, "padding", "")); return ({ zt: a, Qt: c, un: l, It: u }) => { let [d, f] = i(u); const { U: m } = qt(), { _t: h, xt: _, Ct: p } = c || {}, { B: g } = l, [v, b] = a("paddingAbsolute"); (h || f || (u || _)) && ([d, f] = s(u)); const k = !r && (b || p || f); if (k) { const P = !v || !e && !m, M = d.r + d.l, j = d.t + d.b, O = { [Mc]: P && !g ? -M : 0, [Rc]: P ? -j : 0, [Lc]: P && g ? -M : 0, top: P ? -d.t : 0, right: P ? g ? -d.r : "auto" : 0, left: P ? g ? "auto" : -d.l : 0, [Ir]: P && `calc(100% + ${M}px)` }, E = { [kc]: P ? d.t : 0, [Pc]: P ? d.r : 0, [Ic]: P ? d.b : 0, [Oc]: P ? d.l : 0 }; cn(e || n, O), cn(n, E), X(o, { rn: d, fn: !P, F: e ? E : X({}, O, E) }) } return { _n: k } } }, Mf = (t, e) => { const n = qt(), { vt: r, rn: o, L: s, V: i, Kt: a, gt: c, bt: l, yt: u, an: d } = t, { U: f } = n, m = l && i, h = F($c, 0), _ = { display: () => !1, direction: y => y !== "ltr", flexDirection: y => y.endsWith("-reverse"), writingMode: y => y !== "horizontal-tb" }, p = Mt(_), g = { i: Nc, o: { w: 0, h: 0 } }, v = { i: Kn, o: {} }, b = y => { u(rl, !m && y) }, w = y => { if (!p.some((G => { const tt = y[G]; return tt && _[G](tt) }))) return { D: { x: 0, y: 0 }, M: { x: 1, y: 1 } }; b(!0); const x = $t(c), S = u(ef, !0), T = rt(a, Te, (G => { const tt = $t(c); G.isTrusted && tt.x === x.x && tt.y === x.y && Yc(G) }), { I: !0, A: !0 }); Bt(c, { x: 0, y: 0 }), S(); const L = $t(c), H = fr(c); Bt(c, { x: H.w, y: H.h }); const z = $t(c); Bt(c, { x: z.x - L.x < 1 && -H.w, y: z.y - L.y < 1 && -H.h }); const Y = $t(c); return Bt(c, x), ms((() => T())), { D: L, M: Y } }, k = (y, $) => { const x = St.devicePixelRatio % 1 !== 0 ? 1 : 0, S = { w: h(y.w - $.w), h: h(y.h - $.h) }; return { w: S.w > x ? S.w : 0, h: S.h > x ? S.h : 0 } }, P = (y, $) => { const x = (S, T, L, H) => { const z = S === Vt ? Ot : gf(S), Y = be(S), G = be(L); return !T && !H ? Ot : Y && G ? Vt : Y ? T && H ? z : T ? Vt : Ot : T ? z : G && H ? Vt : Ot }; return { x: x($.x, y.x, $.y, y.y), y: x($.y, y.y, $.x, y.x) } }, M = y => { const $ = S => [Vt, Ot, Te].map((T => B(jo(T), S))), x = $(!0).concat($()).join(" "); u(x), u(Mt(y).map((S => B(y[S], S === "x"))).join(" "), !0) }, [j, O] = Et(g, F(As, s)), [E, C] = Et(g, F(fr, s)), [A, N] = Et(g), [q] = Et(v), [K, U] = Et(g), [I] = Et(v), [Z] = Et({ i: (y, $) => Mr(y, $, p), o: {} }, (() => Wh(s) ? jt(s, p) : {})), [W, Q] = Et({ i: (y, $) => Kn(y.D, $.D) && Kn(y.M, $.M), o: Qc() }), R = Ne(Os), B = (y, $) => `${$ ? Yh : Jh}${Hh(y)}`; return ({ zt: y, Qt: $, un: x, It: S }, { _n: T }) => { const { _t: L, Ht: H, xt: z, Ct: Y, ft: G, Et: tt } = $ || {}, V = R && R.R(t, e, x, n, y), { X: ht, Y: mt, W: ut } = V || {}, [wt, st] = mf(y, n), [ct, lt] = y("overflow"), nt = be(ct.x), _t = be(ct.y), yt = L || T || z || Y || tt || st; let De = O(S), Be = C(S), fn = N(S), pn = U(S); if (st && f && u(ol, !wt), yt) { $s(r, Qt, Zn) && b(!0); const Ms = mt && mt(), [xn] = De = j(S), [Sn] = Be = E(S), En = Zc(s), $n = m && Uh(d()), vl = { w: h(Sn.w + xn.w), h: h(Sn.h + xn.h) }, Rs = { w: h(($n ? $n.w : En.w + h(En.w - Sn.w)) + xn.w), h: h(($n ? $n.h : En.h + h(En.h - Sn.h)) + xn.h) }; Ms && Ms(), pn = K(Rs), fn = A(k(vl, Rs), S) } const [mn, gn] = pn, [se, je] = fn, [_n, Dr] = Be, [Br, jr] = De, [Pt, qr] = q({ x: se.w > 0, y: se.h > 0 }), vn = nt && _t && (Pt.x || Pt.y) || nt && Pt.x && !Pt.y || _t && Pt.y && !Pt.x, yn = T || Y || tt || jr || Dr || gn || je || lt || st || yt || H && m, [Fr, wn] = Z(S), qe = Y || G || wn || qr || S, [Fe, bn] = qe ? W(w(Fr), S) : Q(); let Xt = P(Pt, ct); b(!1), yn && (M(Xt), Xt = _f(s, Pt), ut && ht && (ht(Xt, _n, Br), cn(s, ut(Xt)))); const [gl, _l] = I(Xt); return hr(r, Qt, Zn, vn), hr(o, Do, Zn, vn), X(e, { cn: gl, Vt: { x: mn.w, y: mn.h }, Rt: { x: se.w, y: se.h }, j: Pt, Dt: Kh(Fe, se) }), { sn: _l, tn: gn, nn: je, en: bn || je } } }, Rf = t => { const [e, n, r] = Of(t), o = { rn: { t: 0, r: 0, b: 0, l: 0 }, fn: !1, F: { [Mc]: 0, [Rc]: 0, [Lc]: 0, [kc]: 0, [Pc]: 0, [Ic]: 0, [Oc]: 0 }, Vt: { x: 0, y: 0 }, Rt: { x: 0, y: 0 }, cn: { x: Ot, y: Ot }, j: { x: !1, y: !1 }, Dt: Qc() }, { dt: s, gt: i, V: a, St: c } = e, { U: l, k: u } = qt(), d = !l && (u.x || u.y), f = [If(e), Lf(e, o), Mf(e, o)]; return [n, m => { const h = {}, p = d && $t(i), g = p && c(); return J(f, (v => { X(h, v(m, h) || {}) })), Bt(i, p), g && g(), a || Bt(s, 0), h }, o, e, r] }, Nf = (t, e, n, r, o) => { let s = !1; const i = Di(e, {}), [a, c, l, u, d] = Rf(t), [f, m, h] = $f(u, l, i, (w => { b({}, w) })), [_, p, , g] = Pf(t, e, h, l, u, o), v = w => Mt(w).some((k => !!w[k])), b = (w, k) => { if (n()) return !1; const { dn: P, It: M, Tt: j, pn: O } = w, E = P || {}, C = !!M || !s, A = { zt: Di(e, E, C), dn: E, It: C }; if (O) return p(A), !1; const N = k || m(X({}, A, { Tt: j })), q = c(X({}, A, { un: h, Qt: N })); p(X({}, A, { Qt: N, Zt: q })); const K = v(N), U = v(q), I = K || U || !xs(E) || C; return s = !0, I && r(w, { Qt: N, Zt: q }), I }; return [() => { const { ln: w, gt: k, St: P } = u, M = $t(w), j = [f(), a(), _()], O = P(); return Bt(k, M), O(), F(Ct, j) }, b, () => ({ vn: h, gn: l }), { hn: u, bn: g }, d] }, Is = new WeakMap, Hf = (t, e) => { Is.set(t, e) }, Df = t => { Is.delete(t) }, dl = t => Is.get(t), Zt = (t, e, n) => { const { tt: r } = qt(), o = lr(t), s = o ? t : t.target, i = dl(s); if (e && !i) { let a = !1; const c = [], l = {}, u = E => { const C = Dc(E), A = Ne(Zh); return A ? A(C, !0) : C }, d = X({}, r(), u(e)), [f, m, h] = Ho(), [_, p, g] = Ho(n), v = (E, C) => { g(E, C), h(E, C) }, [b, w, k, P, M] = Nf(t, d, (() => a), (({ dn: E, It: C }, { Qt: A, Zt: N }) => { const { _t: q, Ct: K, $t: U, xt: I, Ht: Z, ft: W } = A, { tn: Q, nn: R, sn: B, en: y } = N; v("updated", [O, { updateHints: { sizeChanged: !!q, directionChanged: !!K, heightIntrinsicChanged: !!U, overflowEdgeChanged: !!Q, overflowAmountChanged: !!R, overflowStyleChanged: !!B, scrollCoordinatesChanged: !!y, contentMutation: !!I, hostMutation: !!Z, appear: !!W }, changedOptions: E || {}, force: !!C }]) }), (E => v("scroll", [O, E]))), j = E => { Df(s), Ct(c), a = !0, v("destroyed", [O, E]), m(), p() }, O = { options(E, C) { if (E) { const A = C ? r() : {}, N = il(d, X(A, u(E))); xs(N) || (X(d, N), w({ dn: N })) } return X({}, d) }, on: _, off: (E, C) => { E && C && p(E, C) }, state() { const { vn: E, gn: C } = k(), { B: A } = E, { Vt: N, Rt: q, cn: K, j: U, rn: I, fn: Z, Dt: W } = C; return X({}, { overflowEdge: N, overflowAmount: q, overflowStyle: K, hasOverflow: U, scrollCoordinates: { start: W.D, end: W.M }, padding: I, paddingAbsolute: Z, directionRTL: A, destroyed: a }) }, elements() { const { dt: E, vt: C, rn: A, L: N, ht: q, gt: K, Kt: U } = P.hn, { jt: I, Jt: Z } = P.bn, W = R => { const { Mt: B, Ut: y, Lt: $ } = R; return { scrollbar: $, track: y, handle: B } }, Q = R => { const { Xt: B, Yt: y } = R, $ = W(B[0]); return X({}, $, { clone: () => { const x = W(y()); return w({ pn: !0 }), x } }) }; return X({}, { target: E, host: C, padding: A || N, viewport: N, content: q || N, scrollOffsetElement: K, scrollEventElement: U, scrollbarHorizontal: Q(I), scrollbarVertical: Q(Z) }) }, update: E => w({ It: E, Tt: !0 }), destroy: F(j, !1), plugin: E => l[Mt(E)[0]] }; return it(c, [M]), Hf(s, O), nl(tl, Zt, [O, f, l]), Af(P.hn.bt, !o && t.cancel) ? (j(!0), O) : (it(c, b()), v("initialized", [O]), O.update(), O) } return i }; Zt.plugin = t => { const e = Lt(t), n = e ? t : [t], r = n.map((o => nl(o, Zt)[0])); return Gh(n), e ? r : r[0] }; Zt.valid = t => { const e = t && t.elements, n = Nt(e) && e(); return cr(n) && !!dl(n.target) }; Zt.env = () => { const { P: t, k: e, U: n, J: r, ot: o, st: s, K: i, Z: a, tt: c, nt: l } = qt(); return X({}, { scrollbarsSize: t, scrollbarsOverlaid: e, scrollbarsHiding: n, scrollTimeline: r, staticDefaultInitialization: o, staticDefaultOptions: s, getDefaultInitialization: i, setDefaultInitialization: a, getDefaultOptions: c, setDefaultOptions: l }) }; Zt.nonce = bf; Zt.trustedTypePolicy = Fh;/*!
  * PhotoSwipe Lightbox 5.4.4 - https://photoswipe.com
  * (c) 2024 Dmytro Semenov
  */function Ge(t, e, n) { const r = document.createElement(e); return t && (r.className = t), n && n.appendChild(r), r } function Bf(t, e, n) { let r = `translate3d(${t}px,${e || 0}px,0)`; return n !== void 0 && (r += ` scale3d(${n},${n},1)`), r } function qo(t, e, n) { t.style.width = typeof e == "number" ? `${e}px` : e, t.style.height = typeof n == "number" ? `${n}px` : n } const Tt = { IDLE: "idle", LOADING: "loading", LOADED: "loaded", ERROR: "error" }; function jf(t) { return "button" in t && t.button === 1 || t.ctrlKey || t.metaKey || t.altKey || t.shiftKey } function Ze(t, e, n = document) { let r = []; if (t instanceof Element) r = [t]; else if (t instanceof NodeList || Array.isArray(t)) r = Array.from(t); else { const o = typeof t == "string" ? t : e; o && (r = Array.from(n.querySelectorAll(o))) } return r } function qf(t) { return typeof t == "function" && t.prototype && t.prototype.goTo } function ji() { return !!(navigator.vendor && navigator.vendor.match(/apple/i)) } class Ff { constructor(e, n) { this.type = e, this.defaultPrevented = !1, n && Object.assign(this, n) } preventDefault() { this.defaultPrevented = !0 } } class zf { constructor() { this._listeners = {}, this._filters = {}, this.pswp = void 0, this.options = void 0 } addFilter(e, n, r = 100) { var o, s, i; this._filters[e] || (this._filters[e] = []), (o = this._filters[e]) === null || o === void 0 || o.push({ fn: n, priority: r }), (s = this._filters[e]) === null || s === void 0 || s.sort((a, c) => a.priority - c.priority), (i = this.pswp) === null || i === void 0 || i.addFilter(e, n, r) } removeFilter(e, n) { this._filters[e] && (this._filters[e] = this._filters[e].filter(r => r.fn !== n)), this.pswp && this.pswp.removeFilter(e, n) } applyFilters(e, ...n) { var r; return (r = this._filters[e]) === null || r === void 0 || r.forEach(o => { n[0] = o.fn.apply(this, n) }), n[0] } on(e, n) { var r, o; this._listeners[e] || (this._listeners[e] = []), (r = this._listeners[e]) === null || r === void 0 || r.push(n), (o = this.pswp) === null || o === void 0 || o.on(e, n) } off(e, n) { var r; this._listeners[e] && (this._listeners[e] = this._listeners[e].filter(o => n !== o)), (r = this.pswp) === null || r === void 0 || r.off(e, n) } dispatch(e, n) { var r; if (this.pswp) return this.pswp.dispatch(e, n); const o = new Ff(e, n); return (r = this._listeners[e]) === null || r === void 0 || r.forEach(s => { s.call(this, o) }), o } } class Vf { constructor(e, n) { if (this.element = Ge("pswp__img pswp__img--placeholder", e ? "img" : "div", n), e) { const r = this.element; r.decoding = "async", r.alt = "", r.src = e, r.setAttribute("role", "presentation") } this.element.setAttribute("aria-hidden", "true") } setDisplayedSize(e, n) { this.element && (this.element.tagName === "IMG" ? (qo(this.element, 250, "auto"), this.element.style.transformOrigin = "0 0", this.element.style.transform = Bf(0, 0, e / 250)) : qo(this.element, e, n)) } destroy() { var e; (e = this.element) !== null && e !== void 0 && e.parentNode && this.element.remove(), this.element = null } } class Uf { constructor(e, n, r) { this.instance = n, this.data = e, this.index = r, this.element = void 0, this.placeholder = void 0, this.slide = void 0, this.displayedImageWidth = 0, this.displayedImageHeight = 0, this.width = Number(this.data.w) || Number(this.data.width) || 0, this.height = Number(this.data.h) || Number(this.data.height) || 0, this.isAttached = !1, this.hasSlide = !1, this.isDecoding = !1, this.state = Tt.IDLE, this.data.type ? this.type = this.data.type : this.data.src ? this.type = "image" : this.type = "html", this.instance.dispatch("contentInit", { content: this }) } removePlaceholder() { this.placeholder && !this.keepPlaceholder() && setTimeout(() => { this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0) }, 1e3) } load(e, n) { if (this.slide && this.usePlaceholder()) if (this.placeholder) { const r = this.placeholder.element; r && !r.parentElement && this.slide.container.prepend(r) } else { const r = this.instance.applyFilters("placeholderSrc", this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : !1, this); this.placeholder = new Vf(r, this.slide.container) } this.element && !n || this.instance.dispatch("contentLoad", { content: this, isLazy: e }).defaultPrevented || (this.isImageContent() ? (this.element = Ge("pswp__img", "img"), this.displayedImageWidth && this.loadImage(e)) : (this.element = Ge("pswp__content", "div"), this.element.innerHTML = this.data.html || ""), n && this.slide && this.slide.updateContentSize(!0)) } loadImage(e) { var n, r; if (!this.isImageContent() || !this.element || this.instance.dispatch("contentLoadImage", { content: this, isLazy: e }).defaultPrevented) return; const o = this.element; this.updateSrcsetSizes(), this.data.srcset && (o.srcset = this.data.srcset), o.src = (n = this.data.src) !== null && n !== void 0 ? n : "", o.alt = (r = this.data.alt) !== null && r !== void 0 ? r : "", this.state = Tt.LOADING, o.complete ? this.onLoaded() : (o.onload = () => { this.onLoaded() }, o.onerror = () => { this.onError() }) } setSlide(e) { this.slide = e, this.hasSlide = !0, this.instance = e.pswp } onLoaded() { this.state = Tt.LOADED, this.slide && this.element && (this.instance.dispatch("loadComplete", { slide: this.slide, content: this }), this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode && (this.append(), this.slide.updateContentSize(!0)), (this.state === Tt.LOADED || this.state === Tt.ERROR) && this.removePlaceholder()) } onError() { this.state = Tt.ERROR, this.slide && (this.displayError(), this.instance.dispatch("loadComplete", { slide: this.slide, isError: !0, content: this }), this.instance.dispatch("loadError", { slide: this.slide, content: this })) } isLoading() { return this.instance.applyFilters("isContentLoading", this.state === Tt.LOADING, this) } isError() { return this.state === Tt.ERROR } isImageContent() { return this.type === "image" } setDisplayedSize(e, n) { if (this.element && (this.placeholder && this.placeholder.setDisplayedSize(e, n), !this.instance.dispatch("contentResize", { content: this, width: e, height: n }).defaultPrevented && (qo(this.element, e, n), this.isImageContent() && !this.isError()))) { const r = !this.displayedImageWidth && e; this.displayedImageWidth = e, this.displayedImageHeight = n, r ? this.loadImage(!1) : this.updateSrcsetSizes(), this.slide && this.instance.dispatch("imageSizeChange", { slide: this.slide, width: e, height: n, content: this }) } } isZoomable() { return this.instance.applyFilters("isContentZoomable", this.isImageContent() && this.state !== Tt.ERROR, this) } updateSrcsetSizes() { if (!this.isImageContent() || !this.element || !this.data.srcset) return; const e = this.element, n = this.instance.applyFilters("srcsetSizesWidth", this.displayedImageWidth, this); (!e.dataset.largestUsedSize || n > parseInt(e.dataset.largestUsedSize, 10)) && (e.sizes = n + "px", e.dataset.largestUsedSize = String(n)) } usePlaceholder() { return this.instance.applyFilters("useContentPlaceholder", this.isImageContent(), this) } lazyLoad() { this.instance.dispatch("contentLazyLoad", { content: this }).defaultPrevented || this.load(!0) } keepPlaceholder() { return this.instance.applyFilters("isKeepingPlaceholder", this.isLoading(), this) } destroy() { this.hasSlide = !1, this.slide = void 0, !this.instance.dispatch("contentDestroy", { content: this }).defaultPrevented && (this.remove(), this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0), this.isImageContent() && this.element && (this.element.onload = null, this.element.onerror = null, this.element = void 0)) } displayError() { if (this.slide) { var e, n; let r = Ge("pswp__error-msg", "div"); r.innerText = (e = (n = this.instance.options) === null || n === void 0 ? void 0 : n.errorMsg) !== null && e !== void 0 ? e : "", r = this.instance.applyFilters("contentErrorElement", r, this), this.element = Ge("pswp__content pswp__error-msg-container", "div"), this.element.appendChild(r), this.slide.container.innerText = "", this.slide.container.appendChild(this.element), this.slide.updateContentSize(!0), this.removePlaceholder() } } append() { if (this.isAttached || !this.element) return; if (this.isAttached = !0, this.state === Tt.ERROR) { this.displayError(); return } if (this.instance.dispatch("contentAppend", { content: this }).defaultPrevented) return; const e = "decode" in this.element; this.isImageContent() ? e && this.slide && (!this.slide.isActive || ji()) ? (this.isDecoding = !0, this.element.decode().catch(() => { }).finally(() => { this.isDecoding = !1, this.appendImage() })) : this.appendImage() : this.slide && !this.element.parentNode && this.slide.container.appendChild(this.element) } activate() { this.instance.dispatch("contentActivate", { content: this }).defaultPrevented || !this.slide || (this.isImageContent() && this.isDecoding && !ji() ? this.appendImage() : this.isError() && this.load(!1, !0), this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "false")) } deactivate() { this.instance.dispatch("contentDeactivate", { content: this }), this.slide && this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "true") } remove() { this.isAttached = !1, !this.instance.dispatch("contentRemove", { content: this }).defaultPrevented && (this.element && this.element.parentNode && this.element.remove(), this.placeholder && this.placeholder.element && this.placeholder.element.remove()) } appendImage() { this.isAttached && (this.instance.dispatch("contentAppendImage", { content: this }).defaultPrevented || (this.slide && this.element && !this.element.parentNode && this.slide.container.appendChild(this.element), (this.state === Tt.LOADED || this.state === Tt.ERROR) && this.removePlaceholder())) } } function Wf(t, e) { if (t.getViewportSizeFn) { const n = t.getViewportSizeFn(t, e); if (n) return n } return { x: document.documentElement.clientWidth, y: window.innerHeight } } function jn(t, e, n, r, o) { let s = 0; if (e.paddingFn) s = e.paddingFn(n, r, o)[t]; else if (e.padding) s = e.padding[t]; else { const i = "padding" + t[0].toUpperCase() + t.slice(1); e[i] && (s = e[i]) } return Number(s) || 0 } function Kf(t, e, n, r) { return { x: e.x - jn("left", t, e, n, r) - jn("right", t, e, n, r), y: e.y - jn("top", t, e, n, r) - jn("bottom", t, e, n, r) } } const qi = 4e3; class Gf { constructor(e, n, r, o) { this.pswp = o, this.options = e, this.itemData = n, this.index = r, this.panAreaSize = null, this.elementSize = null, this.fit = 1, this.fill = 1, this.vFill = 1, this.initial = 1, this.secondary = 1, this.max = 1, this.min = 1 } update(e, n, r) { const o = { x: e, y: n }; this.elementSize = o, this.panAreaSize = r; const s = r.x / o.x, i = r.y / o.y; this.fit = Math.min(1, s < i ? s : i), this.fill = Math.min(1, s > i ? s : i), this.vFill = Math.min(1, i), this.initial = this._getInitial(), this.secondary = this._getSecondary(), this.max = Math.max(this.initial, this.secondary, this._getMax()), this.min = Math.min(this.fit, this.initial, this.secondary), this.pswp && this.pswp.dispatch("zoomLevelsUpdate", { zoomLevels: this, slideData: this.itemData }) } _parseZoomLevelOption(e) { const n = e + "ZoomLevel", r = this.options[n]; if (r) return typeof r == "function" ? r(this) : r === "fill" ? this.fill : r === "fit" ? this.fit : Number(r) } _getSecondary() { let e = this._parseZoomLevelOption("secondary"); return e || (e = Math.min(1, this.fit * 3), this.elementSize && e * this.elementSize.x > qi && (e = qi / this.elementSize.x), e) } _getInitial() { return this._parseZoomLevelOption("initial") || this.fit } _getMax() { return this._parseZoomLevelOption("max") || Math.max(1, this.fit * 4) } } function hl(t, e, n) { const r = e.createContentFromData(t, n); let o; const { options: s } = e; if (s) { o = new Gf(s, t, -1); let i; e.pswp ? i = e.pswp.viewportSize : i = Wf(s, e); const a = Kf(s, i, t, n); o.update(r.width, r.height, a) } return r.lazyLoad(), o && r.setDisplayedSize(Math.ceil(r.width * o.initial), Math.ceil(r.height * o.initial)), r } function Zf(t, e) { const n = e.getItemData(t); if (!e.dispatch("lazyLoadSlide", { index: t, itemData: n }).defaultPrevented) return hl(n, e, t) } class Xf extends zf { getNumItems() { var e; let n = 0; const r = (e = this.options) === null || e === void 0 ? void 0 : e.dataSource; r && "length" in r ? n = r.length : r && "gallery" in r && (r.items || (r.items = this._getGalleryDOMElements(r.gallery)), r.items && (n = r.items.length)); const o = this.dispatch("numItems", { dataSource: r, numItems: n }); return this.applyFilters("numItems", o.numItems, r) } createContentFromData(e, n) { return new Uf(e, this, n) } getItemData(e) { var n; const r = (n = this.options) === null || n === void 0 ? void 0 : n.dataSource; let o = {}; Array.isArray(r) ? o = r[e] : r && "gallery" in r && (r.items || (r.items = this._getGalleryDOMElements(r.gallery)), o = r.items[e]); let s = o; s instanceof Element && (s = this._domElementToItemData(s)); const i = this.dispatch("itemData", { itemData: s || {}, index: e }); return this.applyFilters("itemData", i.itemData, e) } _getGalleryDOMElements(e) { var n, r; return (n = this.options) !== null && n !== void 0 && n.children || (r = this.options) !== null && r !== void 0 && r.childSelector ? Ze(this.options.children, this.options.childSelector, e) || [] : [e] } _domElementToItemData(e) { const n = { element: e }, r = e.tagName === "A" ? e : e.querySelector("a"); if (r) { n.src = r.dataset.pswpSrc || r.href, r.dataset.pswpSrcset && (n.srcset = r.dataset.pswpSrcset), n.width = r.dataset.pswpWidth ? parseInt(r.dataset.pswpWidth, 10) : 0, n.height = r.dataset.pswpHeight ? parseInt(r.dataset.pswpHeight, 10) : 0, n.w = n.width, n.h = n.height, r.dataset.pswpType && (n.type = r.dataset.pswpType); const s = e.querySelector("img"); if (s) { var o; n.msrc = s.currentSrc || s.src, n.alt = (o = s.getAttribute("alt")) !== null && o !== void 0 ? o : "" } (r.dataset.pswpCropped || r.dataset.cropped) && (n.thumbCropped = !0) } return this.applyFilters("domItemData", n, e, r) } lazyLoadData(e, n) { return hl(e, this, n) } } class Yf extends Xf { constructor(e) { super(), this.options = e || {}, this._uid = 0, this.shouldOpen = !1, this._preloadedContent = void 0, this.onThumbnailsClick = this.onThumbnailsClick.bind(this) } init() { Ze(this.options.gallery, this.options.gallerySelector).forEach(e => { e.addEventListener("click", this.onThumbnailsClick, !1) }) } onThumbnailsClick(e) { if (jf(e) || window.pswp) return; let n = { x: e.clientX, y: e.clientY }; !n.x && !n.y && (n = null); let r = this.getClickedIndex(e); r = this.applyFilters("clickedIndex", r, e, this); const o = { gallery: e.currentTarget }; r >= 0 && (e.preventDefault(), this.loadAndOpen(r, o, n)) } getClickedIndex(e) { if (this.options.getClickedIndexFn) return this.options.getClickedIndexFn.call(this, e); const n = e.target, o = Ze(this.options.children, this.options.childSelector, e.currentTarget).findIndex(s => s === n || s.contains(n)); return o !== -1 ? o : this.options.children || this.options.childSelector ? -1 : 0 } loadAndOpen(e, n, r) { if (window.pswp || !this.options) return !1; if (!n && this.options.gallery && this.options.children) { const o = Ze(this.options.gallery); o[0] && (n = { gallery: o[0] }) } return this.options.index = e, this.options.initialPointerPos = r, this.shouldOpen = !0, this.preload(e, n), !0 } preload(e, n) { const { options: r } = this; n && (r.dataSource = n); const o = [], s = typeof r.pswpModule; if (qf(r.pswpModule)) o.push(Promise.resolve(r.pswpModule)); else { if (s === "string") throw new Error("pswpModule as string is no longer supported"); if (s === "function") o.push(r.pswpModule()); else throw new Error("pswpModule is not valid") } typeof r.openPromise == "function" && o.push(r.openPromise()), r.preloadFirstSlide !== !1 && e >= 0 && (this._preloadedContent = Zf(e, this)); const i = ++this._uid; Promise.all(o).then(a => { if (this.shouldOpen) { const c = a[0]; this._openPhotoswipe(c, i) } }) } _openPhotoswipe(e, n) { if (n !== this._uid && this.shouldOpen || (this.shouldOpen = !1, window.pswp)) return; const r = typeof e == "object" ? new e.default(this.options) : new e(this.options); this.pswp = r, window.pswp = r, Object.keys(this._listeners).forEach(o => { var s; (s = this._listeners[o]) === null || s === void 0 || s.forEach(i => { r.on(o, i) }) }), Object.keys(this._filters).forEach(o => { var s; (s = this._filters[o]) === null || s === void 0 || s.forEach(i => { r.addFilter(o, i.fn, i.priority) }) }), this._preloadedContent && (r.contentLoader.addToCache(this._preloadedContent), this._preloadedContent = void 0), r.on("destroy", () => { this.pswp = void 0, delete window.pswp }), r.init() } destroy() { var e; (e = this.pswp) === null || e === void 0 || e.destroy(), this.shouldOpen = !1, this._listeners = {}, Ze(this.options.gallery, this.options.gallerySelector).forEach(n => { n.removeEventListener("click", this.onThumbnailsClick, !1) }) } } function Jf() { const t = document.getElementById("scheme-switch"); t && (t.onclick = function () { }); const e = document.getElementById("display-settings-switch"); e && (e.onclick = function () { const r = document.getElementById("display-setting"); r && r.classList.toggle("float-panel-closed") }); const n = document.getElementById("nav-menu-switch"); n && (n.onclick = function () { const r = document.getElementById("nav-menu-panel"); r && r.classList.toggle("float-panel-closed") }) } function Fi(t, e) { document.addEventListener("click", n => { let r = document.getElementById(t), o = n.target; if (o instanceof Node) { for (let s of e) { let i = document.getElementById(s); if (i == o || i?.contains(o)) return } r.classList.add("float-panel-closed") } }) } const Qf = () => ({ show: !1, timer: 0, open: function () { this.timer && window.clearTimeout(this.timer), this.show = !0 }, close: function () { this.timer = window.setTimeout(() => this.show = !1, 300) } }), tp = () => ({ currentValue: localStorage.getItem("color-scheme-fuwari") || "auto", colorSchemes: [{ label: window.i18nResources["jsModule.colorSchemeSwitcher.dark"], value: "dark", icon: "icon-[material-symbols--moon-stars-outline-rounded]" }, { label: window.i18nResources["jsModule.colorSchemeSwitcher.light"], value: "light", icon: "icon-[material-symbols--sunny-outline-rounded]" }, { label: window.i18nResources["jsModule.colorSchemeSwitcher.auto"], value: "auto", icon: "icon-[material-symbols--radio-button-partial-outline]" }], get colorScheme() { return this.colorSchemes.find(t => t.value === this.currentValue) }, switchTheme: function (t) { this.currentValue = t, window.fuwari.setColorScheme(t, !0) } }), ep = (t, e, n) => ({ upvotedNames: [], init() { this.upvotedNames = JSON.parse(localStorage.getItem(`halo.upvoted.${t}.names`) || "[]") }, upvoted(r) { return this.upvotedNames.includes(r) }, async handleUpvote(r) { if (this.upvoted(r)) return; const o = new XMLHttpRequest; o.open("POST", "/apis/api.halo.run/v1alpha1/trackers/upvote"), o.setRequestHeader("Content-Type", "application/json"), o.onload = () => { this.upvotedNames = [...this.upvotedNames, r], localStorage.setItem(`halo.upvoted.${t}.names`, JSON.stringify(this.upvotedNames)); const s = document.querySelector("[data-upvote-" + t + '-name="' + r + '"]'); if (!s) return; const i = parseInt(s.textContent || "0"); s.textContent = i + 1 + "" }, o.onerror = function () { alert(window.i18nResources["jsModule.upvote.networkError"]) }, o.send(JSON.stringify({ group: e, plural: n, name: r })) } }), zi = t => t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); function np(t, ...e) { if (typeof t == "string") return zi(t); let n = t[0]; for (const [r, o] of e.entries()) n = n + zi(String(o)) + t[r + 1]; return n } class rp extends Error { constructor(e) { super(`Missing a value for ${e ? `the placeholder: ${e}` : "a placeholder"}`, e), this.name = "MissingValueError", this.key = e } } function op(t, e, { ignoreMissing: n = !1, transform: r = ({ value: o }) => o } = {}) { if (typeof t != "string") throw new TypeError(`Expected a \`string\` in the first argument, got \`${typeof t}\``); if (typeof e != "object") throw new TypeError(`Expected an \`object\` or \`Array\` in the second argument, got \`${typeof e}\``); const o = (c, l) => { let u = e; for (const f of l.split(".")) u = u ? u[f] : void 0; const d = r({ value: u, key: l }); if (d === void 0) { if (n) return c; throw new rp(l) } return String(d) }, s = c => (...l) => np(c(...l)), i = /{{(\d+|[a-z$_][\w\-$]*?(?:\.[\w\-$]*?)*?)}}/gi; i.test(t) && (t = t.replace(i, s(o))); const a = /{(\d+|[a-z$_][\w\-$]*?(?:\.[\w\-$]*?)*?)}/gi; return t.replace(a, o) } const sp = (t, e) => ({ permalink: window.location.href, title: document.title, shareModal: !1, copied: !1, presetShareItems: [{ id: "x", name: "X", icon: "i-simple-icons-x", type: "url", url: "http://x.com/share?url={url}&text={title}" }, { id: "telegram", name: "Telegram", icon: "i-simple-icons-telegram", type: "url", url: "https://telegram.me/share/url?url={url}&text={title}" }, { id: "facebook", name: "Facebook", icon: "i-simple-icons-facebook", type: "url", url: "https://facebook.com/sharer/sharer.php?u={url}" }, { id: "qq", name: "QQ", icon: "i-simple-icons-tencentqq", type: "url", url: "https://connect.qq.com/widget/shareqq/iframe_index.html?url={url}&title={title}" }, { id: "qzone", name: window.i18nResources["jsModule.share.qzone"], icon: "i-simple-icons-qzone", type: "url", url: "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url={url}&title={title}" }, { id: "weibo", name: window.i18nResources["jsModule.share.weibo"], icon: "i-simple-icons-sinaweibo", type: "url", url: "http://service.weibo.com/share/share.php?url={url}&title={title}" }, { id: "douban", name: window.i18nResources["jsModule.share.douban"], icon: "i-simple-icons-douban", type: "url", url: "https://www.douban.com/share/service?href={url}&name={title}" }, { id: "wechat", name: window.i18nResources["jsModule.share.wechat"], icon: "i-simple-icons-wechat", type: "url", url: "/themes/theme-earth/assets/qrcode-share.html?url={url}" }, { id: "native", name: window.i18nResources["jsModule.share.native"], icon: "i-tabler-device-desktop", type: "native" }], get getShareIds() { return e?.length ? e : t.map(n => n.id) }, get activeShareItems() { return e.map(n => this.presetShareItems.find(r => r.id === n)).filter(Boolean).filter(n => n?.type !== "native" || navigator.canShare?.({ title: this.title, url: this.permalink })) }, handleShare(n) { const r = this.activeShareItems.find(l => l?.id === n); if (!r) return; if (r.type === "native") { if (navigator.share) { navigator.share({ title: this.title, url: this.permalink }); return } return } const o = 1e3, s = 500, i = window.innerHeight / 2 - s / 2, a = window.innerWidth / 2 - o / 2, c = `width=${o}, height= ${s}, top=${i}, left=${a}, status=no, scrollbars=no, resizable=no`; window.open(op(r.url || "", { url: this.permalink, title: this.title }), `${window.i18nResources["jsModule.share.windowTitle"]} - ${this.title}`, c) }, handleCopy() { navigator.clipboard.writeText(this.permalink), this.copied = !0, setTimeout(() => { this.copied = !1 }, 2e3) } }), ip = (t, e) => ({ userPermission: void 0, init() { this.fetchUserPermission() }, get shouldDisplay() { return t === "anonymousUser" || !this.userPermission ? !1 : !!this.userPermission.uiPermissions.includes(e) }, async fetchUserPermission() { const n = await fetch("/apis/api.console.halo.run/v1alpha1/users/-/permissions"); n.ok && (this.userPermission = await n.json()) } }), ap = (t = "#content") => ({ wordCount: 0, readingTime: 0, chineseChars: 0, englishWords: 0, wordCountText: "", readingTimeText: "", locale: document.documentElement.lang || "en", init() { const e = document.querySelector(t); if (!e) { this.wordCount = 0, this.readingTime = 0; return } const n = e.cloneNode(!0); if (!(n instanceof Element)) return; n.querySelectorAll("script, style, code, pre, iframe").forEach(o => o.remove()); const r = (n.textContent ?? "").trim().replace(/\s+/g, " "); this.chineseChars = (r.match(/[\u4e00-\u9fa5]/g) || []).length, this.englishWords = (r.match(/\b[a-zA-Z]+\b/g) || []).length, this.wordCount = this.chineseChars + this.englishWords, this.readingTime = Math.ceil(this.chineseChars / 300 + this.englishWords / 200), this.readingTimeText = this.formatReadingTime(), this.wordCountText = this.formatWordCount() }, formatReadingTime() { const e = this.readingTime; switch (this.locale.toLowerCase()) { case "es": return `${e} minutos`; case "zh_TW": return `${e} `; case "zh_CN": return `${e} `; case "en": return `${e} minutes`; default: return `${e} minutes` } }, formatWordCount() { const e = this.wordCount; switch (this.locale.toLowerCase()) { case "es": return `${e} palabras`; case "zh_TW": return `${e} `; case "zh_CN": return `${e} `; case "en": return `${e} words`; default: return `${e} words` } } }); const pr = 35, fl = 30, cp = pr + fl, lp = 3.5; window.Alpine = re; window.fuwari = { setColorScheme: Ls, getCurrentColorScheme: hp }; const Ut = new oh({ animationSelector: '[class*="transition-swup-"]', containers: ["main"], plugins: [new ih({ persistAssets: !0 }), new ch, new dh, new hh({ head: !1, body: !0 })] }); re.data("dropdown", Qf); re.data("colorSchemeSwitcher", tp); re.data("upvote", ep); re.data("share", sp); re.data("uiPermission", ip); re.data("articleStats", ap); re.start(); function up() { const t = document.querySelector("#theme-config"); if (t?.textContent) try { return JSON.parse(t.textContent) } catch (e) { console.error(" theme-config :", e); return } } const mr = up(); console.log("", mr); function pl() { console.log("Mounting widgets..."); const t = document.querySelector("#counter"); t && Ph(t); const e = document.querySelector("#search"); e && Oh(e); const n = document.querySelector("#display-setting"); n && Ih(n); const r = document.querySelector(".toc"); r && Lh(r) } let Hr = "auto"; function dp(t, e) { let n = t; e && (n = localStorage.getItem("color-scheme-fuwari") || t), Hr = n, Ls(n, !1) } function Ls(t, e) { if (t === "auto") { const n = window.matchMedia("(prefers-color-scheme: dark)").matches; document.documentElement.classList.add(n ? "dark" : "light"), document.documentElement.classList.remove(n ? "light" : "dark") } else document.documentElement.classList.add(t), document.documentElement.classList.remove(t === "dark" ? "light" : "dark"); Hr = t, e && localStorage.setItem("color-scheme-fuwari", t) } function hp() { return Hr } window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", function () { Hr === "auto" && Ls("auto", !1) }); let Xn = !!document.getElementById("banner-wrapper"); function fp() { Ec(Sc()) } function ml() { const t = document.querySelector("body"); if (!t) return; Zt({ target: t, cancel: { nativeScrollbarsOverlaid: !0 } }, { scrollbars: { theme: "scrollbar-base scrollbar-auto py-1", autoHide: "move", autoHideDelay: 500, autoHideSuspend: !1 } }); const e = document.querySelectorAll(".katex-display"), n = { root: null, rootMargin: "100px", threshold: .1 }, r = s => { if (!s.parentNode || s.hasAttribute("data-scrollbar-initialized")) return; const i = document.createElement("div"); i.className = "katex-display-container", i.setAttribute("aria-label", "scrollable container for formulas"), s.parentNode.insertBefore(i, s), i.appendChild(s), Zt(i, { scrollbars: { theme: "scrollbar-base scrollbar-auto", autoHide: "leave", autoHideDelay: 500, autoHideSuspend: !1 } }), s.setAttribute("data-scrollbar-initialized", "true") }, o = new IntersectionObserver((s, i) => { s.forEach(a => { a.isIntersecting && (r(a.target), i.unobserve(a.target)) }) }, n); e.forEach(s => { o.observe(s) }) } function pp() { if (!mr?.base.banner.enable) return; const t = document.getElementById("banner"); if (!t) { console.error("Banner element not found"); return } t.classList.remove("opacity-0", "scale-105") } function mp() { dp(mr?.style.color_scheme, mr?.style.enable_change_color_scheme), fp(), ml(), pp() } const gp = () => { Ut.hooks.on("link:click", () => { if (document.documentElement.style.setProperty("--content-delay", "0ms"), !Xn) return; const t = window.innerHeight * (pr / 100) - 72 - 16, e = document.getElementById("navbar-wrapper"); !e || !document.body.classList.contains("is-home") || (document.body.scrollTop >= t || document.documentElement.scrollTop >= t) && e.classList.add("navbar-hidden") }), Ut.hooks.on("content:replace", t => { const e = t.to.document?.body?.getAttribute("date-page-type"), n = document.querySelector("body"); e === "home" ? n?.classList.add("is-home") : n?.classList.remove("is-home"), document.body?.setAttribute("date-page-type", t.to.document?.body?.getAttribute("date-page-type") || ""), ml() }), Ut.hooks.on("visit:start", () => { const t = document.getElementById("page-height-extend"); t && t.classList.remove("hidden"); const e = document.getElementById("toc-wrapper"); e && e.classList.add("toc-not-ready") }), Ut.hooks.on("page:view", () => { const t = document.getElementById("page-height-extend"); t && t.classList.remove("hidden") }), Ut.hooks.on("visit:end", t => { setTimeout(() => { const e = document.getElementById("page-height-extend"); e && e.classList.add("hidden"); const n = document.getElementById("toc-wrapper"); n && n.classList.remove("toc-not-ready") }, 200) }) }; gp(); window.onresize = () => { let t = Math.floor(window.innerHeight * (fl / 100)); t = t - t % 4, document.documentElement.style.setProperty("--banner-height-extend", `${t}px`) }; let tn; const _p = bl(() => import("./photoswipe.esm.js"), []); function Vi() { tn = new Yf({ gallery: ".custom-md img, #post-cover img", pswpModule: () => _p, closeSVG: '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M480-424 284-228q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 28-11t28 11q11 11 11 28t-11 28L536-480l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480-424Z"/></svg>', zoomSVG: '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M340-540h-40q-17 0-28.5-11.5T260-580q0-17 11.5-28.5T300-620h40v-40q0-17 11.5-28.5T380-700q17 0 28.5 11.5T420-660v40h40q17 0 28.5 11.5T500-580q0 17-11.5 28.5T460-540h-40v40q0 17-11.5 28.5T380-460q-17 0-28.5-11.5T340-500v-40Zm40 220q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l224 224q11 11 11 28t-11 28q-11 11-28 11t-28-11L532-372q-30 24-69 38t-83 14Zm0-80q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg>', padding: { top: 20, bottom: 20, left: 20, right: 20 }, wheelToZoom: !0, arrowPrev: !1, arrowNext: !1, imageClickAction: "close", tapAction: "close", doubleTapAction: "zoom" }), tn.addFilter("domItemData", (t, e) => (e instanceof HTMLImageElement && (t.src = e.src, t.w = Number(e.naturalWidth || window.innerWidth), t.h = Number(e.naturalHeight || window.innerHeight), t.msrc = e.src), t)), tn.init() } const vp = () => { tn || Vi(), Ut.hooks.on("page:view", () => { Vi() }), Ut.hooks.on("content:replace", () => { tn?.destroy?.() }, { before: !0 }) }; vp(); document.addEventListener("DOMContentLoaded", () => { mp(), pl(), Jf(), Fi("display-setting", ["display-setting", "display-settings-switch"]), Fi("nav-menu-panel", ["nav-menu-panel", "nav-menu-switch"]); const t = document.getElementById("back-to-top-btn"), e = document.getElementById("toc-wrapper"), n = document.getElementById("navbar-wrapper"); Xn = !!document.getElementById("banner-wrapper"); function r() { const s = window.innerHeight * (pr / 100); if (t && (document.body.scrollTop > s || document.documentElement.scrollTop > s ? t.classList.remove("hide") : t.classList.add("hide")), Xn && e && (document.body.scrollTop > s || document.documentElement.scrollTop > s ? e.classList.remove("toc-hide") : e.classList.add("toc-hide")), !!Xn && n) { const a = lp * 16; let c = pr; document.body.classList.contains("is-home") && window.innerWidth >= 1024 && (c = cp); const l = window.innerHeight * (c / 100) - 72 - a - 16; document.body.scrollTop >= l || document.documentElement.scrollTop >= l ? n.classList.add("navbar-hidden") : n.classList.remove("navbar-hidden") } } window.onscroll = r; const o = document.getElementById("back-to-top-btn"); o && o.addEventListener("click", () => { window.scrollTo({ top: 0, behavior: "smooth" }) }) }); Ut.hooks.on("visit:start", () => { console.log(window.location.href) }); Ut.hooks.on("content:replace", () => { console.log("Content replaced") }); document.addEventListener("DOMContentLoaded", () => { console.log("DOM fully loaded and parsed"), pl() }); export { hp as getCurrentColorScheme, dp as initColorScheme, Ls as setColorScheme };
